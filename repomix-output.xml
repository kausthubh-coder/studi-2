This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/rules/clerk.mdc
.cursor/rules/convex copy.mdc
.cursor/rules/instructions.mdc
.cursor/rules/nextjs.mdc
.cursor/rules/playwright.mdc
.cursor/rules/tailwind.mdc
.cursor/rules/typescript.mdc
.cursor/rules/vitest.mdc
.gitignore
components/ChatContainer.tsx
components/ChatMessage.tsx
components/MessageInput.tsx
convex/_generated/api.d.ts
convex/_generated/api.js
convex/_generated/dataModel.d.ts
convex/_generated/server.d.ts
convex/_generated/server.js
convex/auth.config.ts
convex/canvas.ts
convex/chats.ts
convex/index.ts
convex/messages.ts
convex/openai.ts
convex/README.md
convex/schema.ts
convex/tsconfig.json
convex/users.ts
docs/architecture.md
docs/canvas-api.md
docs/canvas-function-calling.md
docs/canvas-integration.md
docs/chatbot-architecture.md
docs/components.md
docs/landing-page.md
docs/logger.md
docs/openai-function-calling.md
docs/plan,md
docs/ui-design.md
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
src/app/(auth)/sign-in/page.tsx
src/app/(auth)/sign-up/page.tsx
src/app/(dashboard)/chat/[id]/page.tsx
src/app/(dashboard)/chat/page.tsx
src/app/(dashboard)/dashboard/page.tsx
src/app/(dashboard)/layout.tsx
src/app/(dashboard)/settings/page.tsx
src/app/components/animations.tsx
src/app/components/auth/auth-check.tsx
src/app/components/chat/ChatContainer.tsx
src/app/components/chat/ChatList.tsx
src/app/components/chat/FunctionCallResult.tsx
src/app/components/chat/Message.tsx
src/app/components/chat/MessageInput.tsx
src/app/components/chat/MessageList.tsx
src/app/components/cta.tsx
src/app/components/features.tsx
src/app/components/footer.tsx
src/app/components/hero.tsx
src/app/components/logo.tsx
src/app/components/navigation.tsx
src/app/components/pricing.tsx
src/app/components/testimonials.tsx
src/app/globals.css
src/app/layout.tsx
src/app/page.tsx
src/app/providers.tsx
src/types/chat.ts
src/utils/logger.ts
tailwind.config.js
tsconfig.json
utils/logger.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/clerk.mdc">
---
description: 
globs: 
alwaysApply: false
---
Based on the latest information from March 2025, here are the best practices and most useful features for Clerk:

## Authentication Methods

- Implement Social Sign-On (SSO) for faster user conversion, with support for 20+ providers[1].
- Utilize passwordless authentication options like Magic Links and Email/SMS-based One-Time Passcodes (OTP) for improved security and user experience[3].
- Offer Multi-Factor Authentication (MFA) with SMS passcodes, authenticator apps (TOTP), and hardware keys to prevent 99.9% of account takeovers[3].

## Security Features

- Enable advanced security measures like bot detection, fraud prevention, and abuse protection[1][3].
- Implement session management features, including active device monitoring and session revocation[1][3].
- Utilize Clerk's SOC 2 Type II certification and CCPA compliance for robust security standards[1][3].

## User Management

- Use Clerk's comprehensive suite of embeddable UIs and flexible APIs for complete user management functionality[1].
- Implement user profile management and organization handling tools[5].

## Integration and Customization

- Leverage Clerk's compatibility with modern frameworks like React, Next.js, and Remix[5].
- Utilize Clerk as an OpenID Connect (OIDC) identity provider for external services[4].
- Customize UI components to match your brand while maintaining security best practices[1].

## Performance and User Experience

- Take advantage of Clerk's globally distributed infrastructure for low-latency authentication[3].
- Implement multi-account, multi-device, and multi-session support for enhanced user flexibility[3].

## Development Best Practices

- Use Clerk's pre-built UI components like SignIn, SignUp,UserButton, and UserProfile and  for rapid development[1].
- Implement automatic account linking for users signing in with different methods[3].
- Utilize Clerk's admin dashboards for efficient user management and monitoring[1].
</file>

<file path=".cursor/rules/convex copy.mdc">
---
description: Guidelines and best practices for building Convex projects, including database schema design, queries, mutations, and real-world examples
globs: **/*.{ts,tsx,js,jsx}
alwaysApply: false
---

# Convex guidelines
## Function guidelines
### New function syntax
- ALWAYS use the new function syntax for Convex functions. For example:
      ```typescript
      import { query } from "./_generated/server";
      import { v } from "convex/values";
      export const f = query({
          args: {},
          returns: v.null(),
          handler: async (ctx, args) => {
          // Function body
          },
      });
      ```

### Http endpoint syntax
- HTTP endpoints are defined in `convex/http.ts` and require an `httpAction` decorator. For example:
      ```typescript
      import { httpRouter } from "convex/server";
      import { httpAction } from "./_generated/server";
      const http = httpRouter();
      http.route({
          path: "/echo",
          method: "POST",
          handler: httpAction(async (ctx, req) => {
          const body = await req.bytes();
          return new Response(body, { status: 200 });
          }),
      });
      ```
- HTTP endpoints are always registered at the exact path you specify in the `path` field. For example, if you specify `/api/someRoute`, the endpoint will be registered at `/api/someRoute`.

### Validators
- Below is an example of an array validator:
                            ```typescript
                            import { mutation } from "./_generated/server";
                            import { v } from "convex/values";

                            export default mutation({
                            args: {
                                simpleArray: v.array(v.union(v.string(), v.number())),
                            },
                            handler: async (ctx, args) => {
                                //...
                            },
                            });
                            ```
- Below is an example of a schema with validators that codify a discriminated union type:
                            ```typescript
                            import { defineSchema, defineTable } from "convex/server";
                            import { v } from "convex/values";

                            export default defineSchema({
                                results: defineTable(
                                    v.union(
                                        v.object({
                                            kind: v.literal("error"),
                                            errorMessage: v.string(),
                                        }),
                                        v.object({
                                            kind: v.literal("success"),
                                            value: v.number(),
                                        }),
                                    ),
                                )
                            });
                            ```
- Always use the `v.null()` validator when returning a null value. Below is an example query that returns a null value:
                                  ```typescript
                                  import { query } from "./_generated/server";
                                  import { v } from "convex/values";

                                  export const exampleQuery = query({
                                    args: {},
                                    returns: v.null(),
                                    handler: async (ctx, args) => {
                                        console.log("This query returns a null value");
                                        return null;
                                    },
                                  });
                                  ```
- Here are the valid Convex types along with their respective validators:
 Convex Type  | TS/JS type  |  Example Usage         | Validator for argument validation and schemas  | Notes                                                                                                                                                                                                 |
| ----------- | ------------| -----------------------| -----------------------------------------------| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Id          | string      | `doc._id`              | `v.id(tableName)`                              |                                                                                                                                                                                                       |
| Null        | null        | `null`                 | `v.null()`                                     | JavaScript's `undefined` is not a valid Convex value. Functions the return `undefined` or do not return will return `null` when called from a client. Use `null` instead.                             |
| Int64       | bigint      | `3n`                   | `v.int64()`                                    | Int64s only support BigInts between -2^63 and 2^63-1. Convex supports `bigint`s in most modern browsers.                                                                                              |
| Float64     | number      | `3.1`                  | `v.number()`                                   | Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as strings.                                                                      |
| Boolean     | boolean     | `true`                 | `v.boolean()`                                  |
| String      | string      | `"abc"`                | `v.string()`                                   | Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit when encoded as UTF-8.                                                         |
| Bytes       | ArrayBuffer | `new ArrayBuffer(8)`   | `v.bytes()`                                    | Convex supports first class bytestrings, passed in as `ArrayBuffer`s. Bytestrings must be smaller than the 1MB total size limit for Convex types.                                                     |
| Array       | Array]      | `[1, 3.2, "abc"]`      | `v.array(values)`                              | Arrays can have at most 8192 values.                                                                                                                                                                  |
| Object      | Object      | `{a: "abc"}`           | `v.object({property: value})`                  | Convex only supports "plain old JavaScript objects" (objects that do not have a custom prototype). Objects can have at most 1024 entries. Field names must be nonempty and not start with "$" or "_". |
| Record      | Record      | `{"a": "1", "b": "2"}` | `v.record(keys, values)`                       | Records are objects at runtime, but can have dynamic keys. Keys must be only ASCII characters, nonempty, and not start with "$" or "_".                                                               |

### Function registration
- Use `internalQuery`, `internalMutation`, and `internalAction` to register internal functions. These functions are private and aren't part of an app's API. They can only be called by other Convex functions. These functions are always imported from `./_generated/server`.
- Use `query`, `mutation`, and `action` to register public functions. These functions are part of the public API and are exposed to the public Internet. Do NOT use `query`, `mutation`, or `action` to register sensitive internal functions that should be kept private.
- You CANNOT register a function through the `api` or `internal` objects.
- ALWAYS include argument and return validators for all Convex functions. This includes all of `query`, `internalQuery`, `mutation`, `internalMutation`, `action`, and `internalAction`. If a function doesn't return anything, include `returns: v.null()` as its output validator.
- If the JavaScript implementation of a Convex function doesn't have a return value, it implicitly returns `null`.

### Function calling
- Use `ctx.runQuery` to call a query from a query, mutation, or action.
- Use `ctx.runMutation` to call a mutation from a mutation or action.
- Use `ctx.runAction` to call an action from an action.
- ONLY call an action from another action if you need to cross runtimes (e.g. from V8 to Node). Otherwise, pull out the shared code into a helper async function and call that directly instead.
- Try to use as few calls from actions to queries and mutations as possible. Queries and mutations are transactions, so splitting logic up into multiple calls introduces the risk of race conditions.
- All of these calls take in a `FunctionReference`. Do NOT try to pass the callee function directly into one of these calls.
- When using `ctx.runQuery`, `ctx.runMutation`, or `ctx.runAction` to call a function in the same file, specify a type annotation on the return value to work around TypeScript circularity limitations. For example,
                            ```
                            export const f = query({
                              args: { name: v.string() },
                              returns: v.string(),
                              handler: async (ctx, args) => {
                                return "Hello " + args.name;
                              },
                            });

                            export const g = query({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                const result: string = await ctx.runQuery(api.example.f, { name: "Bob" });
                                return null;
                              },
                            });
                            ```

### Function references
- Function references are pointers to registered Convex functions.
- Use the `api` object defined by the framework in `convex/_generated/api.ts` to call public functions registered with `query`, `mutation`, or `action`.
- Use the `internal` object defined by the framework in `convex/_generated/api.ts` to call internal (or private) functions registered with `internalQuery`, `internalMutation`, or `internalAction`.
- Convex uses file-based routing, so a public function defined in `convex/example.ts` named `f` has a function reference of `api.example.f`.
- A private function defined in `convex/example.ts` named `g` has a function reference of `internal.example.g`.
- Functions can also registered within directories nested within the `convex/` folder. For example, a public function `h` defined in `convex/messages/access.ts` has a function reference of `api.messages.access.h`.

### Api design
- Convex uses file-based routing, so thoughtfully organize files with public query, mutation, or action functions within the `convex/` directory.
- Use `query`, `mutation`, and `action` to define public functions.
- Use `internalQuery`, `internalMutation`, and `internalAction` to define private, internal functions.

### Pagination
- Paginated queries are queries that return a list of results in incremental pages.
- You can define pagination using the following syntax:

                            ```ts
                            import { v } from "convex/values";
                            import { query, mutation } from "./_generated/server";
                            import { paginationOptsValidator } from "convex/server";
                            export const listWithExtraArg = query({
                                args: { paginationOpts: paginationOptsValidator, author: v.string() },
                                handler: async (ctx, args) => {
                                    return await ctx.db
                                    .query("messages")
                                    .filter((q) => q.eq(q.field("author"), args.author))
                                    .order("desc")
                                    .paginate(args.paginationOpts);
                                },
                            });
                            ```
                            Note: `paginationOpts` is an object with the following properties:
                            - `numItems`: the maximum number of documents to return (the validator is `v.number()`)
                            - `cursor`: the cursor to use to fetch the next page of documents (the validator is `v.union(v.string(), v.null())`)
- A query that ends in `.paginate()` returns an object that has the following properties:
                            - page (contains an array of documents that you fetches)
                            - isDone (a boolean that represents whether or not this is the last page of documents)
                            - continueCursor (a string that represents the cursor to use to fetch the next page of documents)


## Validator guidelines
- `v.bigint()` is deprecated for representing signed 64-bit integers. Use `v.int64()` instead.
- Use `v.record()` for defining a record type. `v.map()` and `v.set()` are not supported.

## Schema guidelines
- Always define your schema in `convex/schema.ts`.
- Always import the schema definition functions from `convex/server`:
- System fields are automatically added to all documents and are prefixed with an underscore. The two system fields that are automatically added to all documents are `_creationTime` which has the validator `v.number()` and `_id` which has the validator `v.id(tableName)`.
- Always include all index fields in the index name. For example, if an index is defined as `["field1", "field2"]`, the index name should be "by_field1_and_field2".
- Index fields must be queried in the same order they are defined. If you want to be able to query by "field1" then "field2" and by "field2" then "field1", you must create separate indexes.

## Typescript guidelines
- You can use the helper typescript type `Id` imported from './_generated/dataModel' to get the type of the id for a given table. For example if there is a table called 'users' you can use `Id<'users'>` to get the type of the id for that table.
- If you need to define a `Record` make sure that you correctly provide the type of the key and value in the type. For example a validator `v.record(v.id('users'), v.string())` would have the type `Record<Id<'users'>, string>`. Below is an example of using `Record` with an `Id` type in a query:
                    ```ts
                    import { query } from "./_generated/server";
                    import { Doc, Id } from "./_generated/dataModel";

                    export const exampleQuery = query({
                        args: { userIds: v.array(v.id("users")) },
                        returns: v.record(v.id("users"), v.string()),
                        handler: async (ctx, args) => {
                            const idToUsername: Record<Id<"users">, string> = {};
                            for (const userId of args.userIds) {
                                const user = await ctx.db.get(userId);
                                if (user) {
                                    users[user._id] = user.username;
                                }
                            }

                            return idToUsername;
                        },
                    });
                    ```
- Be strict with types, particularly around id's of documents. For example, if a function takes in an id for a document in the 'users' table, take in `Id<'users'>` rather than `string`.
- Always use `as const` for string literals in discriminated union types.
- When using the `Array` type, make sure to always define your arrays as `const array: Array<T> = [...];`
- When using the `Record` type, make sure to always define your records as `const record: Record<KeyType, ValueType> = {...};`
- Always add `@types/node` to your `package.json` when using any Node.js built-in modules.

## Full text search guidelines
- A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);

## Query guidelines
- Do NOT use `filter` in queries. Instead, define an index in the schema and use `withIndex` instead.
- Convex queries do NOT support `.delete()`. Instead, `.collect()` the results, iterate over them, and call `ctx.db.delete(row._id)` on each result.
- Use `.unique()` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.
- When using async iteration, don't use `.collect()` or `.take(n)` on the result of a query. Instead, use the `for await (const row of query)` syntax.
### Ordering
- By default Convex always returns documents in ascending `_creationTime` order.
- You can use `.order('asc')` or `.order('desc')` to pick whether a query is in ascending or descending order. If the order isn't specified, it defaults to ascending.
- Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.


## Mutation guidelines
- Use `ctx.db.replace` to fully replace an existing document. This method will throw an error if the document does not exist.
- Use `ctx.db.patch` to shallow merge updates into an existing document. This method will throw an error if the document does not exist.

## Action guidelines
- Always add `"use node";` to the top of files containing actions that use Node.js built-in modules.
- Never use `ctx.db` inside of an action. Actions don't have access to the database.
- Below is an example of the syntax for an action:
                    ```ts
                    import { action } from "./_generated/server";

                    export const exampleAction = action({
                        args: {},
                        returns: v.null(),
                        handler: async (ctx, args) => {
                            console.log("This action does not return anything");
                            return null;
                        },
                    });
                    ```

## Scheduling guidelines
### Cron guidelines
- Only use the `crons.interval` or `crons.cron` methods to schedule cron jobs. Do NOT use the `crons.hourly`, `crons.daily`, or `crons.weekly` helpers.
- Both cron methods take in a FunctionReference. Do NOT try to pass the function directly into one of these methods.
- Define crons by declaring the top-level `crons` object, calling some methods on it, and then exporting it as default. For example,
                            ```ts
                            import { cronJobs } from "convex/server";
                            import { internal } from "./_generated/api";
                            import { internalAction } from "./_generated/server";

                            const empty = internalAction({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                console.log("empty");
                              },
                            });

                            const crons = cronJobs();

                            // Run `internal.crons.empty` every two hours.
                            crons.interval("delete inactive users", { hours: 2 }, internal.crons.empty, {});

                            export default crons;
                            ```
- You can register Convex functions within `crons.ts` just like any other file.
- If a cron calls an internal function, always import the `internal` object from '_generated/api`, even if the internal function is registered in the same file.


## File storage guidelines
- Convex includes file storage for large files like images, videos, and PDFs.
- The `ctx.storage.getUrl()` method returns a signed URL for a given file. It returns `null` if the file doesn't exist.
- Do NOT use the deprecated `ctx.storage.getMetadata` call for loading a file's metadata.

                    Instead, query the `_storage` system table. For example, you can use `ctx.db.system.get` to get an `Id<"_storage">`.
                    ```
                    import { query } from "./_generated/server";
                    import { Id } from "./_generated/dataModel";

                    type FileMetadata = {
                        _id: Id<"_storage">;
                        _creationTime: number;
                        contentType?: string;
                        sha256: string;
                        size: number;
                    }

                    export const exampleQuery = query({
                        args: { fileId: v.id("_storage") },
                        returns: v.null();
                        handler: async (ctx, args) => {
                            const metadata: FileMetadata | null = await ctx.db.system.get(args.fileId);
                            console.log(metadata);
                            return null;
                        },
                    });
                    ```
- Convex storage stores items as `Blob` objects. You must convert all items to/from a `Blob` when using Convex storage.


# Examples:
## Example: chat-app

### Task
```
Create a real-time chat application backend with AI responses. The app should:
- Allow creating users with names
- Support multiple chat channels
- Enable users to send messages to channels
- Automatically generate AI responses to user messages
- Show recent message history

The backend should provide APIs for:
1. User management (creation)
2. Channel management (creation)
3. Message operations (sending, listing)
4. AI response generation using OpenAI's GPT-4

Messages should be stored with their channel, author, and content. The system should maintain message order
and limit history display to the 10 most recent messages per channel.

```

### Analysis
1. Task Requirements Summary:
- Build a real-time chat backend with AI integration
- Support user creation
- Enable channel-based conversations
- Store and retrieve messages with proper ordering
- Generate AI responses automatically

2. Main Components Needed:
- Database tables: users, channels, messages
- Public APIs for user/channel management
- Message handling functions
- Internal AI response generation system
- Context loading for AI responses

3. Public API and Internal Functions Design:
Public Mutations:
- createUser:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({userId: v.id("users")})
  - purpose: Create a new user with a given name
- createChannel:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({channelId: v.id("channels")})
  - purpose: Create a new channel with a given name
- sendMessage:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), authorId: v.id("users"), content: v.string()}
  - returns: v.null()
  - purpose: Send a message to a channel and schedule a response from the AI

Public Queries:
- listMessages:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
    }))
  - purpose: List the 10 most recent messages from a channel in descending creation order

Internal Functions:
- generateResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.null()
  - purpose: Generate a response from the AI for a given channel
- loadContext:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }))
- writeAgentResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), content: v.string()}
  - returns: v.null()
  - purpose: Write an AI response to a given channel

4. Schema Design:
- users
  - validator: { name: v.string() }
  - indexes: <none>
- channels
  - validator: { name: v.string() }
  - indexes: <none>
- messages
  - validator: { channelId: v.id("channels"), authorId: v.optional(v.id("users")), content: v.string() }
  - indexes
    - by_channel: ["channelId"]

5. Background Processing:
- AI response generation runs asynchronously after each user message
- Uses OpenAI's GPT-4 to generate contextual responses
- Maintains conversation context using recent message history


### Implementation

#### package.json
```typescript
{
  "name": "chat-app",
  "description": "This example shows how to build a chat app without authentication.",
  "version": "1.0.0",
  "dependencies": {
    "convex": "^1.17.4",
    "openai": "^4.79.0"
  },
  "devDependencies": {
    "typescript": "^5.7.3"
  }
}
```

#### tsconfig.json
```typescript
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "exclude": ["convex"],
  "include": ["**/src/**/*.tsx", "**/src/**/*.ts", "vite.config.ts"]
}
```

#### convex/index.ts
```typescript
import {
  query,
  mutation,
  internalQuery,
  internalMutation,
  internalAction,
} from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";
import { internal } from "./_generated/api";

/**
 * Create a user with a given name.
 */
export const createUser = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("users"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("users", { name: args.name });
  },
});

/**
 * Create a channel with a given name.
 */
export const createChannel = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("channels"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("channels", { name: args.name });
  },
});

/**
 * List the 10 most recent messages from a channel in descending creation order.
 */
export const listMessages = query({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      _id: v.id("messages"),
      _creationTime: v.number(),
      channelId: v.id("channels"),
      authorId: v.optional(v.id("users")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);
    return messages;
  },
});

/**
 * Send a message to a channel and schedule a response from the AI.
 */
export const sendMessage = mutation({
  args: {
    channelId: v.id("channels"),
    authorId: v.id("users"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const user = await ctx.db.get(args.authorId);
    if (!user) {
      throw new Error("User not found");
    }
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      authorId: args.authorId,
      content: args.content,
    });
    await ctx.scheduler.runAfter(0, internal.index.generateResponse, {
      channelId: args.channelId,
    });
    return null;
  },
});

const openai = new OpenAI();

export const generateResponse = internalAction({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const context = await ctx.runQuery(internal.index.loadContext, {
      channelId: args.channelId,
    });
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: context,
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("No content in response");
    }
    await ctx.runMutation(internal.index.writeAgentResponse, {
      channelId: args.channelId,
      content,
    });
    return null;
  },
});

export const loadContext = internalQuery({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      role: v.union(v.literal("user"), v.literal("assistant")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);

    const result = [];
    for (const message of messages) {
      if (message.authorId) {
        const user = await ctx.db.get(message.authorId);
        if (!user) {
          throw new Error("User not found");
        }
        result.push({
          role: "user" as const,
          content: `${user.name}: ${message.content}`,
        });
      } else {
        result.push({ role: "assistant" as const, content: message.content });
      }
    }
    return result;
  },
});

export const writeAgentResponse = internalMutation({
  args: {
    channelId: v.id("channels"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      content: args.content,
    });
    return null;
  },
});
```

#### convex/schema.ts
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  channels: defineTable({
    name: v.string(),
  }),

  users: defineTable({
    name: v.string(),
  }),

  messages: defineTable({
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }).index("by_channel", ["channelId"]),
});
```

#### src/App.tsx
```typescript
export default function App() {
  return <div>Hello World</div>;
}
```
</file>

<file path=".cursor/rules/instructions.mdc">
---
description: 
globs: 
alwaysApply: true
---
# Fullstack Development Guide

## Project Setup and Structure
- Create a modular folder structure separating components, hooks, utils, and pages
- Use src/app for Next.js app router files
- Keep API-related code in convex directory for backend logic
- Place reusable components in src/components directory
- Store utility functions in src/utils
- Create custom hooks in src/hooks for shared logic

## Development Workflow
- Start with writing tests first (Test-Driven Development)
- Create unit tests for individual components and functions
- Write integration tests for connected components
- Implement end-to-end tests with Playwright to verify user flows
- Use descriptive commit messages following conventional commits format
- Review code regularly using ESLint and TypeScript type checking

## Next.js Best Practices
- Use the App Router for improved SEO and performance
- Implement React Server Components for reducing client-side JavaScript
- Create layout components for consistent page structure
- Use next/image for automatic image optimization
- Implement lazy loading with next/dynamic for non-essential components
- Use server actions for form handling and data mutations
- Create API routes in app/api directory for backend functionality
- Utilize Next.js built-in SEO features like metadata API

## TypeScript Practices
- Use explicit types for function parameters and return values
- Create interfaces for consistent data structures
- Leverage TypeScript's type inference where appropriate
- Use unknown instead of any for better type safety
- Implement proper error handling with custom error types
- Use type guards for runtime type checking
- Create utility types for common patterns

## Convex Database Guidelines
- Define your schema in convex/schema.ts with proper types
- Use the new function syntax for Convex functions
- Create queries using withIndex instead of filter for better performance
- Implement proper pagination for listing data
- Use mutations for data modifications
- Create actions for integrating with external services like OpenAI
- Properly validate arguments with Convex validators
- Use internal functions for sensitive operations
- Implement proper error handling in database operations

## Authentication with Clerk
- Use ClerkProvider at the root of your application
- Implement SignIn and SignUp components for authentication
- Create protected routes using middleware
- Use useAuth hook to access authentication state
- Implement custom user profiles with Clerk's API
- Store Clerk user IDs in your Convex database for associations
- Use Clerk's webhooks for user lifecycle events

## Testing Strategy
- Write unit tests with Vitest for individual components
- Create integration tests for connected components
- Implement end-to-end tests with Playwright
- Use mocks for external dependencies
- Test error handling scenarios
- Write tests for authentication flows
- Use the watch mode for rapid feedback during development

## UI Development with Tailwind CSS
- Use Tailwind's utility classes directly in your JSX
- Create consistent components with shared styling
- Implement responsive design using Tailwind's breakpoint utilities
- Extract common patterns into custom Tailwind components
- Use the theme configuration for consistent colors and spacing
- Create a design system with reusable UI components
- Implement dark mode support with Tailwind's dark mode utilities
- have a 

## AI Integration Best Practices
- Use OpenAI API with proper error handling and retries
- Implement vector storage for efficient similarity searches
- Create wrapper functions around AI capabilities
- Use streaming responses for better user experience
- Implement proper rate limiting and fallbacks
- Handle API errors gracefully with user-friendly messages
- Cache expensive AI operations where appropriate

## Performance Optimization
- Use React Server Components for data-fetching components
- Implement static generation for content that doesn't change often
- Use incremental static regeneration for semi-dynamic content
- Optimize images with next/image
- Implement proper code splitting with dynamic imports
- Use React.memo and useMemo for expensive calculations
- Monitor and optimize database queries

## Deployment and DevOps
- Set up CI/CD pipelines for automated testing and deployment
- Use environment variables for configuration
- Implement proper logging for debugging
- Set up monitoring for production applications
- Create staging environments for testing before production
- Use proper versioning for your API
- Implement database migrations for schema changes

## Security Considerations
- Never store API keys in client-side code
- Use environment variables for sensitive information
- Implement proper authentication and authorization
- Validate user inputs on both client and server
- Use HTTPS for all communications
- Implement rate limiting for API endpoints
- Keep dependencies updated for security patches
</file>

<file path=".cursor/rules/nextjs.mdc">
---
description: 
globs: *.tsx,src/app/*
alwaysApply: false
---
Based on the latest information from March 2025, here are the best practices and most useful features for Next.js:

## Enhanced Rendering Techniques

- Utilize improved Incremental Static Regeneration (ISR), Server-Side Rendering (SSR), and Static Site Generation (SSG) for faster load speeds[1].
- Leverage React Server Components (RSC) to reduce client-side JavaScript execution[1].
- Implement Edge Functions and streaming to improve page load speed by rendering closer to users[1].

## App Directory Improvements

- Use the restructured app directory for better scalability and modularity[1].
- Implement layouts that automatically apply to nested routes for improved project organization[1].
- Utilize new data fetching techniques like getServerSideProps and getStaticProps directly within the app directory[1].

## Performance Optimization

- Use the Next.js Image component (next/image) for automatic image optimization, including WebP format, CDN-based optimization, and lazy loading[1][3].
- Implement lazy loading and code splitting using next/dynamic for non-essential components[3].
- Utilize partial rendering and progressive hydration to shorten Time to Interactive (TTI)[1].

## SEO and Accessibility Enhancements

- Use integrated meta tag optimization and improved schema markup to raise search engine rankings[1].
- Implement the Next.js next/head API for appropriate titles, meta descriptions, and Open Graph tags[1].
- Use structured data in JSON-LD for comprehensive search results[1].

## Server Actions and API Handling

- Utilize Server Actions for simplified backend interactions without complex API layers[4].
- Implement Route Handlers for efficient backend processing and data retrieval[1].

## Mobile-First Optimization

- Use CSS Grid and Flexbox for responsive layouts without media queries[1].
- Implement container queries to dynamically adjust components based on available space[1].
- Use hardware-accelerated animations to avoid janky scroll behavior on mobile devices[1].

## Advanced Routing and Layouts

- Take advantage of the file-based routing system centered around the app directory[4].
- Use nested layouts to improve code organization and reduce complexity in multi-route applications[4].

## Data Fetching and Caching

- Utilize async APIs for cookies, headers, params, and searchParams to prepare data before the request arrives[4].
- Note that fetch requests and GET route handlers are no longer cached by default in Next.js 15, allowing for more control over performance[4][5].

## Security and Middleware

- Implement Next.js middleware for authentication, A/B testing, and request pre-processing[1].
- Use environment variables safely and enable strict Content Security Policy (CSP) for enhanced security[1].
</file>

<file path=".cursor/rules/playwright.mdc">
---
description: 
globs: 
alwaysApply: false
---

## Test Structure and Organization

- Implement the Page Object Model (POM) design pattern for better test organization and maintainability[1].
- Use fixtures for efficient test setup and teardown[1].
- Leverage in-source testing for quick function testing without separate test files[2].

## Locator Strategies

- Use stable, unique locators like data-testid, aria-label, or name attributes[1][5].
- Leverage semantic HTML and simple CSS selectors for better stability[1][5].
- Utilize role-based selectors that identify elements by their purpose[3].
- Keep all selectors in a central file for easier maintenance[3].

## Performance and Efficiency

- Utilize parallel testing to run multiple tests concurrently, reducing execution time[4].
- Implement sharding to distribute tests across multiple worker processes or machines[4].
- Use the watch mode for rapid feedback during development[2].

## Cross-Browser and Mobile Testing

- Take advantage of Playwright's multi-browser support for Chromium, Firefox, and WebKit[6].
- Utilize mobile test automation capabilities for testing mobile web applications[4].

## Advanced Features

- Implement visual regression testing using Playwright's visual comparison API[2].
- Use auto-waiting functionality to ensure elements are actionable before performing actions[5][6].
- Leverage browser context management for efficient handling of multiple tabs or windows[2].

## Integration and Compatibility

- Utilize Playwright's compatibility with Vite's config, transformers, resolvers, and plugins[2].
- Integrate with CI/CD processes for seamless automation in software pipelines[4].

## Security and Reliability

- Keep Playwright updated to benefit from security patches and new features[2].
- Implement proper test isolation to prevent interference between tests[2].

## Emerging Trends

- Explore AI-driven testing capabilities for dynamic maintenance and predictive analysis[4].
- Consider integrating with data fabric architecture for optimized automation workflows[4].

By following these best practices and leveraging Playwright's latest features, developers and QA specialists can create more reliable, efficient, and maintainable test automation in 2025.
</file>

<file path=".cursor/rules/tailwind.mdc">
---
description: 
globs: 
alwaysApply: false
---

## Project Structure and Organization

- Keep Tailwind styles in a dedicated `styles.css` file[1].
- Organize components into modular files for better maintainability[1].
- Use `@layer` directives for base, components, and utilities to manage global styles effectively[1].

## Performance Optimization

- Utilize the Just-in-Time (JIT) compiler, which is now the default engine, for faster builds and reduced CSS file size[1][5].
- Enable purging of unused styles by configuring the `content` option in `tailwind.config.js`[5]:

```javascript
module.exports = {
  content: ['./src/**/*.{html,js,jsx,ts,tsx,vue}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

## Customization and Theming

- Leverage the `tailwind.config.js` file to define custom themes, colors, spacing, and typography[1].
- Use the new OKLCH color space for improved color accessibility, especially in dark mode[3].
- Implement dark mode by enabling it in the configuration and using the `dark:` prefix for classes[1].

## Responsive Design

- Follow Tailwind's mobile-first approach using responsive prefixes like `md:` and `lg:`[1].
- Utilize Flexbox and Grid utilities for creating flexible, responsive layouts[1].
- Implement container queries for more granular control over component responsiveness[2].

## Accessibility and SEO

- Use Tailwind's built-in accessibility tools to ensure good contrast and readability[1].
- Implement ARIA attributes for better accessibility in interactive elements[1].
- Optimize website speed by leveraging Tailwind's performance benefits, contributing to better SEO rankings[2].

## New Features and Best Practices

- Take advantage of the expanded color palette, which now includes previously disabled colors like cyan, rose, fuchsia, and lime[5].
- Use the `@apply` directive to create reusable styles and avoid excessive utility class duplication[1].
- Leverage Tailwind plugins for added functionality, such as forms and typography[1].

## Integration with Modern Frameworks

- Utilize Tailwind CSS with component-based frameworks like React or Vue for better organization in large projects[1][2].
- Take advantage of Tailwind's compatibility with Next.js and other modern web development frameworks[2].

## Advanced Techniques

- Use the CLI to update components and take advantage of new features, such as improved dark mode colors[3].
- Implement custom UI components using Tailwind's utility classes for consistent design across projects[1].
</file>

<file path=".cursor/rules/typescript.mdc">
---
description: 
globs: 
alwaysApply: true
---
 Follow clean code principles
- Prefer async/await over callbacks
- Write comprehensive error handling

## Type Safety and Annotations

- Use explicit types for variables, function parameters, and return values to improve code readability and catch errors early[1][4].
- Leverage TypeScript's type inference capabilities where possible to reduce verbosity while maintaining strong type guarantees[4].
- Enable strict mode in tsconfig.json to ensure more rigorous type checking[2].
- Utilize the `unknown` type instead of `any` for safer handling of variables with uncertain types[4].

## Advanced Type Features

- Employ mapped types to transform existing types into new ones[4].
- Utilize template literal types for dynamic type creation[4].
- Implement conditional types for flexible and dynamic type assignments[4].

## Generics and Utility Types

- Use generics for creating reusable and flexible components[1].
- Leverage built-in utility types like `Partial`, `Readonly`, `Record`, `Pick`, and `Omit` for easy type manipulation[1].
- Create custom utility types for specific use cases in your projects[1].

## Code Organization and Modularity

- Organize your code into modules and use named exports for better maintainability[1].
- Implement interfaces for defining object shapes and type aliases for complex types[1].

## Error Handling and Type Guards

- Use custom error types for more precise error handling[1].
- Implement type guards for runtime type checks and narrowing[1][4].

## Performance and Optimization

- Utilize lazy loading and code splitting techniques to improve application performance[1].
- Ensure unused code is removed during the build process through tree shaking[1].

## Tooling and Integration

- Use ESLint with TypeScript to catch potential issues early and maintain code quality[1][4].
- Integrate Prettier for consistent code formatting across your project[1][4].
- Leverage modern build tools like ESBuild and Vite, which offer out-of-the-box TypeScript support[4].

## AI and Machine Learning Integration

- Use TypeScript with machine learning libraries like TensorFlow.js for type-safe AI-driven applications[4].
- Integrate TypeScript with AI-driven coding assistants like GitHub Copilot for enhanced productivity[4].

## React-Specific Best Practices

- When using TypeScript with React, ensure proper configuration and strict type checking[5].
- Implement type-safe event handling in React components[5].
</file>

<file path=".cursor/rules/vitest.mdc">
---
description: 
globs: 
alwaysApply: false
---
## Performance Optimization

- Utilize the Just-in-Time (JIT) compiler for faster test execution and reduced setup time[1].
- Implement proper test isolation to prevent test interference and improve reliability[1].
- Use the watch mode effectively for rapid feedback during development[1].

## Advanced Testing Techniques

- Leverage in-source testing for quick function testing without separate test files[3].
- Use `.only` to focus on specific tests during development, improving efficiency[3].
- Implement component testing for Vue, React, Svelte, Lit, and Marko[7].

## Integration and Configuration

- Take advantage of Vitest's compatibility with Vite's config, transformers, resolvers, and plugins[7].
- Use the same setup from your app to run tests, ensuring consistency between development and testing environments[7].
- Implement workspace support for better organization in large projects[7].

## Security and Reliability

- Keep Vitest updated to benefit from security patches, such as those addressing remote code execution vulnerabilities[2].
- Utilize the `diff.maxDepth` option to reduce the risk of crashes when dealing with complex objects[2].

## Feature Utilization

- Implement smart and instant watch mode for HMR-like testing experience[7].
- Use built-in Chai for assertions with Jest-compatible expect APIs[7].
- Leverage Tinyspy for mocking, stubbing, and spies[7].
- Utilize workers multi-threading via Tinypool for improved performance in large test suites[7].

## Browser Testing

- Explore the new browser mode for running component tests directly in the browser[7].
- Consider using the UI mode for better test debugging and visualization[1].

## TypeScript and Modern JavaScript Support

- Take advantage of out-of-the-box TypeScript and JSX support[7].
- Utilize top-level await and ESM-first approach for modern JavaScript testing[7].

## Additional Best Practices

- Implement sharding for distributing test load across multiple machines or processes[7].
- Use filtering, timeouts, and concurrent execution for optimizing test runs[7].
- Leverage snapshot testing for UI components and complex objects[7].
- Implement type testing using expect-type for enhanced type-level assertions[7].
</file>

<file path="docs/plan,md">
# Studi - AI-Driven Educational App

## Objective
To create an AI-driven educational app that integrates with Canvas LMS, providing personalized learning experiences through vector databases, AI-generated content, and interactive tools.

## Tech Stack

- **Frontend:** Next.js, Tailwind CSS
- **Backend:** Convex
- **Authentication:** Clerk
- **AI and NLP:** LangChain, OpenAI API

## App Requirements

- **User Authentication:** Secure login using Canvas credentials via Clerk.
- **Data Integration:** Seamless integration with Canvas to fetch assignments, files, and modules.
- **Vector Database:** Create a vector space for each class to store and retrieve context-aware information.
- **AI Chatbot:** Contextual chatbot for class-specific queries, with @ referencing for files.
- **Dashboard:** Display upcoming assignments, tests, and progress overview.
- **Artifact Creation:** Generate quizzes, notes, flashcards, and interactive lessons.
- **Search and Retrieval:** Efficient search capabilities using vector databases.

## Features

### Dashboard
- Overview of assignments, upcoming events, and class insights.

### Class-Specific Views
- Start new chats, view old chats, and manage artifacts.

### Artifact Creation
- Support for quizzes, flashcards, and notes.

### Real-Time Function Execution
- AI agents can fetch and update knowledge dynamically.

## Subscription Model

- **Free Plan:** 10-20 cents of usage per user.
- **Paid Plan:** $8 subscription unlocking up to $5 worth of additional usage.

## Convex File Storage
- Used for storing and retrieving documents efficiently.

## Performance Optimization
- Ensure fast response times for simple chats.
- AI agents manage function calls and knowledge updates dynamically.

## Analytics Implementation
- User activity and engagement tracking.

## Database Tables and Schema

### Users
| Field           | Type      |
|----------------|----------|
| id            | Unique identifier |
| name          | String |
| email         | String |
| canvasId      | String |
| universityUrl | String |
| canvasAccessToken | String |

### Documents
| Field           | Type      |
|----------------|----------|
| id            | Unique identifier |
| userId        | Foreign key to Users |
| content       | Text |
| metadata      | JSON |
| vectorEmbedding | Vector data |
| classId       | Foreign key to Classes |

### Chats
| Field           | Type      |
|----------------|----------|
| id            | Unique identifier |
| userId        | Foreign key to Users |
| classId       | Foreign key to Classes |
| createdAt     | DateTime |

### ChatMessages
| Field           | Type      |
|----------------|----------|
| id            | Unique identifier |
| chatId        | Foreign key to Chats |
| userId        | Foreign key to Users |
| content       | Text |
| createdAt     | DateTime |

### Artifacts
| Field           | Type      |
|----------------|----------|
| id            | Unique identifier |
| userId        | Foreign key to Users |
| classId       | Foreign key to Classes |
| type          | Enum (Quiz, Note, Flashcard) |
| content       | JSON |
| createdAt     | DateTime |
| metadata      | JSON |

### Classes
| Field           | Type      |
|----------------|----------|
| id            | Unique identifier |
| userId        | Foreign key to Users (Owner) |
| name          | String |
| createdAt     | DateTime |

## Best Practices

### Code Quality
- Follow clean code principles.
- Use async/await for handling asynchronous operations.
- Implement comprehensive error handling.

### Security
- Ensure data privacy and secure handling of user credentials.

### Scalability
- Design the vector database for efficient scaling.

### Performance
- Optimize data retrieval and AI processing for fast response times.

## Testing

- **Unit Testing:** Test individual components and functions.
- **Integration Testing:** Ensure seamless integration between Canvas, AI, and the app.
- **User Testing:** Conduct usability testing to gather feedback and improve UX.

## UI/UX Design

- **User-Centric Design:** Focus on intuitive navigation and accessibility.
- **Responsive Design:** Ensure compatibility across devices.
- **Visual Consistency:** Maintain a clean and modern UI with white and black themes with emoji-based visual cues.

## Deployment Plan

- **Hosting:** Likely Vercel for frontend and Convex for backend.
- **Mobile Support:** Web app first, mobile support may be added later.
- **Beta Launch:** Initial MVP with a waitlist within a week.
- **Development Tools:** AI-powered code editors like Cursor for assistance.

## Future Features

- **Enhanced Artifact Creation:** Support for interactive websites, Desmos simulations, whiteboards, and collaborative editing.
- **Real-Time Collaboration:** Enable sharing and collaborative editing of chats and artifacts.
- **Expanded AI Capabilities:** More robust knowledge integration for AI-driven learning assistance.
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="components/ChatContainer.tsx">
import React, { useRef, useEffect } from 'react';
import { ChatMessage } from './ChatMessage';

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  functionCall?: {
    name: string;
    arguments: any;
    result: any;
  };
}

interface ChatContainerProps {
  messages: Message[];
  isLoading?: boolean;
}

export const ChatContainer: React.FC<ChatContainerProps> = ({ 
  messages, 
  isLoading = false 
}) => {
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4">
      {messages.length === 0 ? (
        <div className="h-full flex flex-col items-center justify-center text-center p-8">
          <h2 className="text-2xl font-bold text-gray-700 dark:text-gray-300">
            Welcome to Studi
          </h2>
          <p className="mt-2 text-gray-600 dark:text-gray-400">
            Start a conversation with the AI assistant to help with your studies.
          </p>
        </div>
      ) : (
        <>
          {messages.map((message) => (
            <ChatMessage
              key={message.id}
              id={message.id}
              content={message.content}
              role={message.role}
              timestamp={message.timestamp}
              functionCall={message.functionCall}
            />
          ))}
        </>
      )}
      
      {isLoading && (
        <div className="flex justify-center ml-8 my-4">
          <div className="animate-pulse bg-gray-200 dark:bg-gray-700 rounded-lg p-4 max-w-md">
            <div className="h-4 bg-gray-300 dark:bg-gray-600 rounded w-3/4 mb-2"></div>
            <div className="h-4 bg-gray-300 dark:bg-gray-600 rounded w-1/2"></div>
          </div>
        </div>
      )}
      
      <div ref={messagesEndRef} />
    </div>
  );
};
</file>

<file path="components/ChatMessage.tsx">
import React from 'react';
import ReactMarkdown from 'react-markdown';
import { format } from 'date-fns';

interface FunctionCall {
  name: string;
  arguments: any;
  result: any;
}

interface ChatMessageProps {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  functionCall?: FunctionCall;
}

export const ChatMessage: React.FC<ChatMessageProps> = ({
  content,
  role,
  timestamp,
  functionCall,
}) => {
  // Function to render function call details
  const renderFunctionCallDetails = () => {
    if (!functionCall) return null;
    
    return (
      <div className="mt-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-md text-xs">
        <div className="font-semibold text-indigo-600 dark:text-indigo-400">
          Function called: {functionCall.name}
        </div>
        <div className="mt-1">
          <div className="font-medium">Arguments:</div>
          <pre className="p-2 bg-gray-100 dark:bg-gray-900 rounded overflow-x-auto">
            {JSON.stringify(functionCall.arguments, null, 2)}
          </pre>
        </div>
        <div className="mt-1">
          <div className="font-medium">Result:</div>
          <pre className="p-2 bg-gray-100 dark:bg-gray-900 rounded overflow-x-auto">
            {JSON.stringify(functionCall.result, null, 2)}
          </pre>
        </div>
      </div>
    );
  };

  return (
    <div 
      className={`mb-4 ${
        role === 'user' 
          ? 'mr-8 flex justify-start' 
          : 'ml-8 flex justify-center'
      }`}
    >
      <div 
        className={`relative ${
          role === 'user' 
            ? 'bg-blue-100 dark:bg-blue-900 rounded-lg p-4' 
            : 'prose dark:prose-invert max-w-3xl'
        }`}
      >
        {role === 'user' ? (
          <p className="text-gray-800 dark:text-gray-200">{content}</p>
        ) : (
          <div className="prose-sm sm:prose-base lg:prose-lg dark:prose-invert max-w-none">
            <ReactMarkdown>{content}</ReactMarkdown>
            {functionCall && renderFunctionCallDetails()}
          </div>
        )}
        <div className={`text-xs text-gray-500 mt-1 ${
          role === 'user' ? 'text-right' : 'text-center'
        }`}>
          {format(timestamp, 'h:mm a')}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="components/MessageInput.tsx">
import React, { useState, FormEvent } from 'react';

interface MessageInputProps {
  onSendMessage: (message: string) => void;
  disabled?: boolean;
}

export const MessageInput: React.FC<MessageInputProps> = ({ 
  onSendMessage, 
  disabled = false 
}) => {
  const [message, setMessage] = useState('');

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (message.trim() && !disabled) {
      onSendMessage(message);
      setMessage('');
    }
  };

  return (
    <form 
      onSubmit={handleSubmit} 
      className="border-t border-gray-200 dark:border-gray-700 p-4 bg-white dark:bg-gray-800"
    >
      <div className="flex items-center space-x-2">
        <input
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Type your message..."
          className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={disabled}
        />
        <button
          type="submit"
          disabled={disabled || !message.trim()}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
        >
          Send
        </button>
      </div>
    </form>
  );
};
</file>

<file path="convex/_generated/api.js">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
</file>

<file path="convex/_generated/dataModel.d.ts">
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
</file>

<file path="convex/_generated/server.d.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;
</file>

<file path="convex/_generated/server.js">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/auth.config.ts">
export default {
    providers: [
      {
        domain: "https://proper-adder-1.clerk.accounts.dev",
        applicationID: "convex",
      },
    ]
  };
</file>

<file path="convex/chats.ts">
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Id } from "./_generated/dataModel";

// Create a new chat
export const createChat = mutation({
  args: {
    title: v.string(),
  },
  handler: async (ctx, args) => {
    // Get user identity
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthorized: Please sign in to create a chat");
    }

    // Get user from database
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new Error("User not found");
    }

    // Create a new chat
    const chatId = await ctx.db.insert("chats", {
      userId: user._id,
      title: args.title,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    return chatId;
  },
});

// Get all chats for the current user
export const getChats = query({
  args: {},
  handler: async (ctx) => {
    // Get user identity
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    // Get user from database
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      return [];
    }

    // Get all chats for this user, sorted by most recent first
    const chats = await ctx.db
      .query("chats")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .order("desc")
      .collect();

    return chats;
  },
});

// Get a specific chat by ID
export const getChat = query({
  args: {
    chatId: v.id("chats"),
  },
  handler: async (ctx, args) => {
    const chat = await ctx.db.get(args.chatId);
    if (!chat) {
      throw new Error("Chat not found");
    }

    // Optional: Check if the user has access to this chat
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthorized");
    }

    return chat;
  },
});

// Delete a chat
export const deleteChat = mutation({
  args: {
    chatId: v.id("chats"),
  },
  handler: async (ctx, args) => {
    // Get user identity
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthorized");
    }

    // Get user
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new Error("User not found");
    }

    // Get the chat
    const chat = await ctx.db.get(args.chatId);
    if (!chat) {
      throw new Error("Chat not found");
    }

    // Check if the user owns this chat
    if (chat.userId !== user._id) {
      throw new Error("Unauthorized: You don't have permission to delete this chat");
    }

    // Delete all messages in this chat
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_chatId", (q) => q.eq("chatId", args.chatId))
      .collect();

    for (const message of messages) {
      await ctx.db.delete(message._id);
    }

    // Delete the chat
    await ctx.db.delete(args.chatId);

    return { success: true };
  },
});

// Update a chat
export const updateChat = mutation({
  args: {
    id: v.id("chats"),
    title: v.string(),
  },
  handler: async (ctx, args) => {
    // Get user identity
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthorized");
    }

    // Get user
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new Error("User not found");
    }

    // Get the chat
    const chat = await ctx.db.get(args.id);
    if (!chat) {
      throw new Error("Chat not found");
    }

    // Check if the user owns this chat
    if (chat.userId !== user._id) {
      throw new Error("Unauthorized: You don't have permission to update this chat");
    }

    // Update the chat
    await ctx.db.patch(args.id, {
      title: args.title,
      updatedAt: Date.now(),
    });

    return { success: true };
  },
});
</file>

<file path="convex/index.ts">
// Main API exports for the Convex app
// This file re-exports functions from various modules to make them available to clients

// OpenAI integration - Only export the public functions
export { generateChatCompletion } from "./openai";

// Canvas integration - Create public wrappers for internal functions
import { action } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// Type for Canvas API response
type CanvasResponse<T> = {
  success: boolean;
  data?: T;
  error?: string;
};

// Public wrapper for getCourses
export const getCourses = action({
  args: {},
  handler: async (ctx): Promise<CanvasResponse<any[]>> => {
    // Get the authenticated user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return { success: false, error: "Not authenticated" };
    }
    
    try {
      // Get the user ID first
      const userId = await getUserId(ctx, identity.subject);
      if (!userId) {
        return { success: false, error: "User not found" };
      }
      
      // Call the internal Canvas function
      const response = await ctx.runAction(internal.canvas.getCourses, { 
        userId: userId
      });
      return response;
    } catch (error) {
      console.error("Error fetching courses:", error);
      return { success: false, error: `Failed to fetch courses: ${error}` };
    }
  },
});

// Public wrapper for getAssignments
export const getAssignments = action({
  args: {
    courseId: v.string()
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    // Get the authenticated user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return { success: false, error: "Not authenticated" };
    }
    
    try {
      // Get the user ID first
      const userId = await getUserId(ctx, identity.subject);
      if (!userId) {
        return { success: false, error: "User not found" };
      }
      
      // Call the internal Canvas function
      const response = await ctx.runAction(internal.canvas.getAssignments, { 
        userId: userId,
        courseId: args.courseId
      });
      return response;
    } catch (error) {
      console.error("Error fetching assignments:", error);
      return { success: false, error: `Failed to fetch assignments: ${error}` };
    }
  },
});

// Public wrapper for getAnnouncements
export const getAnnouncements = action({
  args: {
    courseId: v.string()
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    // Get the authenticated user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return { success: false, error: "Not authenticated" };
    }
    
    try {
      // Get the user ID first
      const userId = await getUserId(ctx, identity.subject);
      if (!userId) {
        return { success: false, error: "User not found" };
      }
      
      // Call the internal Canvas function
      const response = await ctx.runAction(internal.canvas.getAnnouncements, { 
        userId: userId,
        courseId: args.courseId
      });
      return response;
    } catch (error) {
      console.error("Error fetching announcements:", error);
      return { success: false, error: `Failed to fetch announcements: ${error}` };
    }
  },
});

// Public wrapper for getModules
export const getModules = action({
  args: {
    courseId: v.string()
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    // Get the authenticated user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return { success: false, error: "Not authenticated" };
    }
    
    try {
      // Get the user ID first
      const userId = await getUserId(ctx, identity.subject);
      if (!userId) {
        return { success: false, error: "User not found" };
      }
      
      // Call the internal Canvas function
      const response = await ctx.runAction(internal.canvas.getModules, { 
        userId: userId,
        courseId: args.courseId
      });
      return response;
    } catch (error) {
      console.error("Error fetching modules:", error);
      return { success: false, error: `Failed to fetch modules: ${error}` };
    }
  },
});

// Helper function to get user ID from Clerk subject ID
async function getUserId(ctx: any, clerkSubject: string): Promise<Id<"users"> | null> {
  const user = await ctx.runQuery(internal.users.getUserByClerkId, { 
    clerkId: clerkSubject 
  });
  
  if (!user) {
    return null;
  }
  
  return user._id;
}

// User management
export { getUser, createOrUpdateUser, updateCanvasSettings } from "./users";

// Message handling
export { getMessages, sendMessage } from "./messages";
</file>

<file path="convex/README.md">
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.
</file>

<file path="convex/tsconfig.json">
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
</file>

<file path="docs/canvas-api.md">
# Canvas API Integration Documentation

This document describes the Canvas LMS API functions implemented in our chatbot application using Convex and OpenAI function calling.

## Overview

Our application integrates with the Canvas Learning Management System API to provide users with access to their educational data. This enables the AI chatbot to respond to queries about courses, assignments, grades, and other educational resources directly from Canvas.

## Authentication

All Canvas API calls require authentication using a Canvas API token. Users must provide:

1. A Canvas API access token
2. The URL of their Canvas instance (e.g., `https://canvas.instructure.com`)

These credentials are stored securely in the user document in the database and used for all subsequent API calls.

## Available Functions

### Courses

#### `getCourses`
- **Description**: Retrieves a list of courses in which the user is enrolled
- **Args**: `userId`
- **Returns**: List of course objects with details such as name, ID, code, and start/end dates

### Assignments

#### `getAssignments`
- **Description**: Retrieves assignments for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of assignment objects with details such as name, description, due dates, and submission status

### Announcements

#### `getAnnouncements`
- **Description**: Retrieves announcements for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of announcement objects with details such as title, message, and post date

### Modules

#### `getModules`
- **Description**: Retrieves modules for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of module objects with details such as name, position, and unlock date

#### `getModuleItems`
- **Description**: Retrieves items within a specific module
- **Args**: `userId`, `courseId`, `moduleId`
- **Returns**: List of module item objects with details such as title, type, URL, and content

### Files

#### `getFiles`
- **Description**: Retrieves files for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of file objects with details such as name, size, type, and creation date

#### `getFileDownloadUrl`
- **Description**: Retrieves a download URL for a specific file
- **Args**: `userId`, `fileId`
- **Returns**: String URL that can be used to download the file

### Grades

#### `getCourseGrades`
- **Description**: Retrieves assignment grades for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of assignment objects with submission and grade information

#### `getEnrollmentGrades`
- **Description**: Retrieves overall grades for all enrolled courses
- **Args**: `userId`
- **Returns**: List of enrollment objects with course grade information

### Discussions

#### `getDiscussions`
- **Description**: Retrieves discussion topics for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of discussion topic objects with details such as title, message, and replies count

#### `getDiscussionDetails`
- **Description**: Retrieves details for a specific discussion topic including entries and replies
- **Args**: `userId`, `courseId`, `discussionId`
- **Returns**: Discussion topic object with entries and replies

### User Information

#### `getUserProfile`
- **Description**: Retrieves the user's profile information
- **Args**: `userId`
- **Returns**: User profile object with details such as name, email, and bio

#### `getUserEnrollments`
- **Description**: Retrieves the user's enrollments (courses with roles)
- **Args**: `userId`
- **Returns**: List of enrollment objects with course and role information

### Calendar & Events

#### `getCalendarEvents`
- **Description**: Retrieves calendar events for the user
- **Args**: `userId`, `startDate` (optional), `endDate` (optional)
- **Returns**: List of calendar event objects with details such as title, description, and dates

#### `getUpcomingEvents`
- **Description**: Retrieves upcoming events and assignments with due dates
- **Args**: `userId`
- **Returns**: List of upcoming event objects with details such as title, type, and due date

### Quizzes & Surveys

#### `getQuizzes`
- **Description**: Retrieves quizzes for a specific course
- **Args**: `userId`, `courseId`
- **Returns**: List of quiz objects with details such as title, description, and availability dates

#### `getQuizDetails`
- **Description**: Retrieves details for a specific quiz including questions
- **Args**: `userId`, `courseId`, `quizId`
- **Returns**: Quiz object with details and questions

## Error Handling

All Canvas API functions include consistent error handling:

1. User validation - Ensures the user exists and has Canvas credentials
2. API request errors - Handles HTTP errors from the Canvas API
3. General error handling - Catches and logs any unexpected errors

All functions return a standardized `CanvasResponse` object with the following structure:
```typescript
{
  success: boolean;      // Whether the request was successful
  data?: T;              // The data returned (when success is true)
  error?: string;        // Error message (when success is false)
}
```

## Integration with OpenAI Function Calling

The Canvas API functions are integrated with OpenAI's function calling capabilities through the `openai.ts` file. Each Canvas function is registered as an available tool that OpenAI can call when appropriate for responding to user queries.

The functions are described to the AI with clear parameter information, allowing it to choose the right function and parameters based on the user's query.

## Example Usage

When a user asks a question like "What assignments do I have in my Physics course?", the following process occurs:

1. The AI recognizes this as a request for assignments in a specific course
2. The AI first calls `getCourses` to find the user's courses
3. It identifies the Physics course and gets its ID
4. It then calls `getAssignments` with the Physics course ID
5. Finally, it formats and presents the assignment information to the user

## Documentation Resources

For more information about the Canvas API, refer to the official Canvas LMS API documentation:
- [Canvas LMS API Documentation](https://canvas.instructure.com/doc/api/index.html)
- [Canvas API Authentication](https://canvas.instructure.com/doc/api/file.oauth.html)
</file>

<file path="docs/canvas-function-calling.md">
# Canvas Function Calling

## Overview

The Canvas function calling feature allows the Studi AI chatbot to interact with the Canvas LMS API on behalf of the user. This enables the chatbot to retrieve course information, assignments, announcements, and other educational data directly from Canvas.

## Features

- Retrieve courses from Canvas
- Get assignments for specific courses
- View course announcements
- Access module information
- Seamless integration with the chat interface

## Technical Implementation

### Function Calling Architecture

The Canvas function calling feature uses OpenAI's function calling capability to:

1. Detect when a user's query requires Canvas data
2. Call the appropriate Canvas API endpoint
3. Process the data and present it in a user-friendly format
4. Continue the conversation with context from the Canvas data

### Canvas API Integration

The integration uses the Canvas REST API with the following endpoints:

- `/api/v1/courses` - Get user's courses
- `/api/v1/courses/:id/assignments` - Get assignments for a course
- `/api/v1/courses/:id/announcements` - Get announcements for a course
- `/api/v1/courses/:id/modules` - Get modules for a course

### Security Considerations

- Canvas API tokens are stored securely in the database
- All API requests are made server-side
- Function calls are logged for audit purposes
- Users can revoke access at any time by disabling Canvas integration

## User Guide

### Prerequisites

Before using Canvas function calling:

1. Enable Canvas integration in Settings
2. Configure your Canvas URL
3. Add your Canvas API access token

### Example Queries

Users can ask questions like:

- "What courses am I enrolled in?"
- "Show me assignments for my Biology course"
- "What are the recent announcements in my Math class?"
- "List the modules in my History course"

### Interpreting Results

The chatbot will display Canvas data in a structured format within the chat interface, making it easy to browse and understand the information.

## Troubleshooting

### Common Issues

1. **"Canvas integration not configured"** - Ensure Canvas integration is enabled in Settings
2. **"Unable to access Canvas API"** - Verify your Canvas URL and access token
3. **"Course not found"** - Check that you're using the correct course ID or name

### Support

If you encounter issues with Canvas function calling, please contact support at support@studiapp.com.
</file>

<file path="docs/canvas-integration.md">
# Canvas LMS Integration

This document describes the Canvas Learning Management System (LMS) integration with our chat application.

## Overview

The Canvas integration allows users to interact with their Canvas LMS data through the chat interface. Users can ask questions about their courses, assignments, announcements, and modules, and the application will fetch the relevant data from Canvas via its API.

## Components

The Canvas integration consists of the following components:

1. **Canvas API Client**: A set of functions that handle communication with the Canvas API.
2. **Function Calling**: Integration with OpenAI's function calling capabilities to detect when to access Canvas data.
3. **User Settings**: User-specific Canvas settings (access token and URL).

## Canvas API Functions

The following functions are available to fetch data from Canvas:

### `getCourses(userId)`

Fetches a list of active courses for the user.

**Parameters:**
- `userId`: The ID of the user

**Returns:**
- Success response: `{ success: true, data: courses }`
- Error response: `{ success: false, error: errorMessage }`

### `getAssignments(userId, courseId)`

Fetches assignments for a specific course.

**Parameters:**
- `userId`: The ID of the user
- `courseId`: The Canvas course ID

**Returns:**
- Success response: `{ success: true, data: assignments }`
- Error response: `{ success: false, error: errorMessage }`

### `getAnnouncements(userId, courseId)`

Fetches announcements for a specific course.

**Parameters:**
- `userId`: The ID of the user
- `courseId`: The Canvas course ID

**Returns:**
- Success response: `{ success: true, data: announcements }`
- Error response: `{ success: false, error: errorMessage }`

### `getModules(userId, courseId)`

Fetches modules for a specific course.

**Parameters:**
- `userId`: The ID of the user
- `courseId`: The Canvas course ID

**Returns:**
- Success response: `{ success: true, data: modules }`
- Error response: `{ success: false, error: errorMessage }`

## OpenAI Function Integration

The Canvas functions are exposed to OpenAI's GPT-4o model through function definitions in the chat completion API. When the model detects that a user's question requires Canvas data, it can call the appropriate function.

The function definitions are:

```javascript
const canvasFunctions = [
  {
    name: "get_courses",
    description: "Get the user's courses from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  {
    name: "get_assignments",
    description: "Get assignments for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_announcements",
    description: "Get announcements for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_modules",
    description: "Get modules for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  }
];
```

## User Settings

Users can enable or disable Canvas integration and configure their Canvas settings through the application. The following settings are available:

- `canvasEnabled`: Whether Canvas integration is enabled for the user
- `canvasAccessToken`: The user's Canvas API access token
- `canvasUrl`: The URL of the user's Canvas instance

These settings are stored in the user's document in the database.

## Flow of Data

1. User sends a message asking about Canvas data (e.g., "What courses am I taking?")
2. The message is sent to OpenAI's API with Canvas function definitions
3. If the model decides to call a Canvas function, it returns a function call
4. The application executes the function, fetching data from Canvas
5. The data is formatted and sent back to OpenAI's API
6. The model generates a human-readable response based on the Canvas data
7. The response is displayed to the user

## Error Handling

The Canvas integration includes robust error handling:

- Checks if Canvas integration is enabled for the user
- Verifies that the user has provided valid Canvas credentials
- Handles API errors from Canvas
- Provides clear error messages to the user

## Security

To ensure security:

- Canvas access tokens are stored securely in the database
- All API requests to Canvas use HTTPS
- Canvas function calls are only made when the user's question explicitly requires Canvas data
- Users can disable Canvas integration at any time

## Future Improvements

Potential future improvements to the Canvas integration:

1. Support for more Canvas API endpoints (e.g., calendar events, grades, etc.)
2. Caching of Canvas data to reduce API calls
3. Improved error handling and retry mechanisms
4. Better formatting of Canvas data in responses
5. Support for file uploads and downloads from Canvas
</file>

<file path="docs/chatbot-architecture.md">
# AI Chatbot Architecture Documentation

This document provides an overview of the architecture and implementation details of the AI chatbot feature in our application.

## System Overview

The AI chatbot is implemented using a combination of:

- **Next.js** for the frontend UI
- **Tailwind CSS** for styling
- **Convex** for the backend and database
- **OpenAI** for the AI chat completion
- **Clerk** for authentication and user management

## Data Model

### Schema

The chatbot functionality relies on three main data tables:

1. **Users**
   - Stores user information and subscription details
   - Tracks usage tokens for billing and limits

2. **Chats**
   - Represents chat sessions created by users
   - Contains metadata like title and timestamps

3. **Messages**
   - Stores individual messages within chat sessions
   - Contains the content, role (user/assistant), and token usage

## Component Architecture

### Backend Components

1. **Convex Schema (`schema.ts`)**
   - Defines the database schema for users, chats, and messages
   - Sets up indexes for efficient queries

2. **OpenAI Integration (`openai.ts`)**
   - Handles communication with the OpenAI API
   - Manages prompt formatting and response processing

3. **Chat Management (`chats.ts`)**
   - Provides functions for creating, retrieving, and deleting chats
   - Enforces access control based on user authentication

4. **Message Management (`messages.ts`)**
   - Handles sending and retrieving messages
   - Tracks token usage for billing purposes

### Frontend Components

1. **Chat Container (`ChatContainer.tsx`)**
   - Serves as the main wrapper for the chat interface
   - Manages state and data flow between components

2. **Message List (`MessageList.tsx`)**
   - Displays the list of messages in a conversation
   - Handles auto-scrolling and loading states

3. **Message Component (`Message.tsx`)**
   - Renders individual messages with appropriate styling
   - Provides copy functionality for AI responses

4. **Message Input (`MessageInput.tsx`)**
   - Handles user input and message submission
   - Provides keyboard shortcuts and loading states

5. **Chat List (`ChatList.tsx`)**
   - Shows the list of user's chat conversations
   - Allows creating new chats and deleting existing ones

## Authentication and Authorization

- **Clerk Authentication** is used to secure all chat-related routes
- **Convex Auth** ensures users can only access their own data
- Each database query and mutation verifies user identity before proceeding

## OpenAI Integration

- The application uses the OpenAI Chat Completions API
- Messages are sent with proper context for conversational continuity
- System prompts establish the assistant's personality and capabilities
- Token usage is tracked for each request to manage billing and limits

## Performance Considerations

1. **Message Pagination**
   - Only the most recent messages are sent to OpenAI to stay within token limits
   - Older messages can be loaded on demand

2. **Real-time Updates**
   - Convex provides real-time data synchronization for immediate updates

3. **Token Management**
   - Token usage is tracked to prevent exceeding rate limits or quotas
   - Users on different subscription tiers have different usage limits

## Future Enhancements

1. **Streaming Responses**
   - Implement streaming for real-time display of AI responses

2. **File Attachments**
   - Allow users to upload and reference files in conversations

3. **Enhanced Context Management**
   - Implement more sophisticated context management for longer conversations

4. **Custom Instructions**
   - Allow users to set persistent custom instructions for their assistant

## Error Handling

- Robust error handling throughout the application
- Graceful degradation when API limits are reached
- Clear user feedback for all error states
</file>

<file path="docs/landing-page.md">
# Studi Landing Page Documentation

This document provides detailed information about the landing page design and implementation for Studi, an AI-powered Canvas LMS assistant.

## Overview

The landing page is designed to showcase Studi's value proposition with a focus on Canvas LMS integration. The design follows modern web standards and best practices for conversion optimization, with a clean, professional aesthetic that appeals to students and educators.

## Design Principles

- **Focus on Canvas Integration**: Emphasize the unique selling point of Canvas LMS integration
- **Clear Value Proposition**: Communicate benefits clearly and concisely
- **Modern Aesthetic**: Use contemporary design elements with a clean, professional look
- **Conversion-Optimized**: Structure designed to guide visitors toward the sign-up action
- **Responsive Design**: Fully functional across all device sizes
- **Accessibility**: Ensure the page is accessible to all users

## Page Sections

### Hero Section

The hero section is the first thing visitors see and introduces Studi as an AI-powered study assistant for Canvas LMS.

**Key Elements:**
- Animated background with network pattern
- Headline with typewriter effect: "Your AI-Powered Study Assistant"
- Subheadline emphasizing Canvas integration
- Call-to-action buttons for early access
- Interactive preview showing a sample chat interaction
- Responsive design that adapts to different screen sizes

**Implementation:**
- Located in `src/app/components/hero.tsx`
- Uses the `Typewriter` animation component
- Implements responsive design with Tailwind CSS

### Features Section

The features section highlights the key capabilities of Studi with visual illustrations.

**Key Elements:**
- Grid layout of feature cards
- Icon illustrations for each feature
- Brief, benefit-focused descriptions
- Animated reveal on scroll

**Features Highlighted:**
- Canvas LMS Integration
- AI-Powered Study Assistance
- Smart Assignment Help
- Course Material Organization
- Personalized Study Plans
- Collaborative Learning

**Implementation:**
- Located in `src/app/components/features.tsx`
- Uses the `Reveal` animation component
- Implements responsive grid layout with Tailwind CSS

### Testimonials Section

The testimonials section builds trust by showcasing real user experiences.

**Key Elements:**
- Carousel of testimonial cards
- User avatars and names
- Star ratings
- Testimonial text focusing on benefits
- Subtle animations on hover

**Implementation:**
- Located in `src/app/components/testimonials.tsx`
- Uses responsive card design
- Implements hover effects for interactive feel

### Call to Action (CTA) Section

The CTA section encourages visitors to sign up for early access.

**Key Elements:**
- Eye-catching background with gradient
- Clear headline and subheadline
- Email input field
- Submit button
- Privacy policy link

**Implementation:**
- Located in `src/app/components/cta.tsx`
- Uses form validation for email input
- Implements responsive design for all devices

### Navigation

The navigation bar provides easy access to different sections of the landing page.

**Key Elements:**
- Logo and beta badge
- Desktop navigation links
- Authentication buttons (Sign in, Get Early Access)
- Mobile-responsive menu with hamburger icon
- Scroll effect that changes background on scroll

**Implementation:**
- Located in `src/app/components/navigation.tsx`
- Uses framer-motion for animations
- Implements responsive design with mobile menu

### Footer

The footer section contains links, information, and copyright notice.

**Key Elements:**
- Logo and company description
- Organized link sections (Product, Resources, Company, Legal)
- Social media links
- Copyright information

**Implementation:**
- Located in `src/app/components/footer.tsx`
- Uses responsive grid layout
- Dynamically updates copyright year

## Responsive Design

The landing page is fully responsive and optimized for various device sizes:

- **Desktop**: Full layout with all elements visible
- **Tablet**: Adjusted grid layouts and spacing
- **Mobile**: Stacked layout with hamburger menu navigation

## Performance Considerations

- Optimized images and SVGs
- Lazy loading for below-the-fold content
- Minimal use of heavy animations
- Efficient component rendering

## Future Enhancements

Potential future enhancements for the landing page include:

1. **A/B Testing**: Test different headlines and CTAs for conversion optimization
2. **Video Demo**: Add a short video demonstrating the Canvas integration
3. **Customer Logos**: Add logos of educational institutions using Studi
4. **Interactive Demo**: Add an interactive demo that visitors can try without signing up
5. **Localization**: Add support for multiple languages

## Related Documentation

- [Components Documentation](components.md)
- [UI Design Guidelines](ui-design.md)
- [Canvas Integration Documentation](canvas-integration.md)
</file>

<file path="docs/logger.md">
# Logger Utility Documentation

## Overview

The logger utility provides a structured logging system for the application. It supports different log levels and context tagging to help organize and filter logs based on their importance and source.

## Features

- **Multiple Log Levels**: Supports 'debug', 'info', 'warn', and 'error' log levels
- **Context Tagging**: Allows categorizing logs by context (app, api, chat, ui, canvas, auth, etc.)
- **Environment-Aware**: Automatically adjusts log level based on the environment (development vs. production)
- **Formatted Output**: Includes timestamps and context tags for better readability
- **Flexible API**: Supports both string and object data logging

## Usage

### Basic Usage

```typescript
import { logger } from "../utils/logger";

// Basic logging with default context ('app')
logger.debug("Debug message");
logger.info("Info message");
logger.warn("Warning message");
logger.error("Error message");
```

### Logging with Context

```typescript
// Logging with specific context
logger.debug("User authentication attempt", { context: 'auth' });
logger.info("API request received", { context: 'api' });
logger.warn("Rate limit approaching", { context: 'api' });
logger.error("Database connection failed", { context: 'db' });
```

### Logging Objects

```typescript
// Logging objects
logger.info("User data", { 
  context: 'auth',
  data: { userId: '123', email: 'user@example.com' } 
});

// Error with additional data
logger.error("Request failed", { 
  context: 'api',
  error: new Error('Network error'),
  request: { url: '/api/data', method: 'GET' }
});
```

### Direct Use of Log Function

```typescript
import { log } from "../utils/logger";

// Using the core log function directly
log('Custom message', { 
  level: 'info',
  context: 'custom',
  timestamp: new Date().toISOString(),
  data: { custom: 'data' }
});
```

## Configuration

The logger automatically sets the appropriate log level based on the environment:

- In production (`NODE_ENV === 'production'`): Only logs with level 'info' and above are displayed
- In development: All logs including 'debug' level are displayed

## Log Level Priorities

Log levels are prioritized as follows (from lowest to highest):

1. debug
2. info
3. warn
4. error

Logs with a priority lower than the current environment's log level will not be displayed.

## Implementation Details

The logger is implemented in `src/utils/logger.ts` and uses the browser's console methods for output. Each log level corresponds to a specific console method:

- debug → console.debug
- info → console.info
- warn → console.warn
- error → console.error

## Best Practices

1. Use the appropriate log level based on the message's importance
2. Include relevant context to make filtering easier
3. For errors, include the error object and any relevant request data
4. Use structured data (objects) for complex information rather than string concatenation
5. Avoid logging sensitive information (passwords, tokens, etc.)
</file>

<file path="docs/openai-function-calling.md">
# OpenAI Function Calling

This document explains how OpenAI function calling is implemented in our chat application to enable integration with Canvas LMS.

## Overview

OpenAI's function calling capability allows the AI model to request specific functions to be executed based on user input. Our implementation uses this feature to enable the chat AI to access Canvas LMS data when a user asks about their courses, assignments, or other educational resources.

## Implementation Details

### Function Definitions

Function definitions are structured according to OpenAI's requirements, specifying:
- Name of the function
- Description of what the function does
- Parameters the function accepts (in JSON Schema format)

```javascript
const canvasFunctions = [
  {
    name: "get_courses",
    description: "Get the user's courses from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  // Other function definitions...
];
```

### OpenAI API Integration

When a user sends a message that might require Canvas data, the application:

1. Formats previous messages and the new user message
2. Calls the OpenAI API with function definitions included
3. Checks if the model wants to call a function
4. If a function call is requested, executes the function
5. Sends the function result back to OpenAI
6. Returns the final response to the user

### Code Flow

The main chat completion function:

```typescript
export const generateChatCompletion = action({
  args: {
    messages: v.array(
      v.object({
        role: v.string(),
        content: v.string(),
      })
    ),
    chatId: v.id("chats"),
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<GenerateChatCompletionResponse> => {
    // Get OpenAI client
    const openai = await getOpenAIClient();
    
    try {
      // Get user to check if Canvas is enabled
      const user = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      // Prepare system message with Canvas capability if enabled
      const systemMessage = {
        role: "system",
        content: "You are a helpful AI assistant. " + 
                 (user?.canvasEnabled ? "You can access the user's Canvas LMS data." : "")
      };
      
      // Format messages for OpenAI
      const formattedMessages = [
        systemMessage,
        ...args.messages
      ];
      
      // Include Canvas functions if enabled
      const functions = user?.canvasEnabled ? canvasFunctions : [];
      
      // First API call
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: formattedMessages,
        functions: functions.length > 0 ? functions : undefined,
        function_call: functions.length > 0 ? "auto" : undefined,
      });
      
      // Check if model wants to call a function
      if (response.choices[0]?.message?.function_call) {
        // Execute function and get result
        const functionResult = await executeCanvasFunction(
          ctx, 
          args.userId, 
          response.choices[0].message.function_call
        );
        
        // Second API call with function result
        const secondResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [
            ...formattedMessages,
            {
              role: "assistant",
              content: null,
              function_call: response.choices[0].message.function_call
            },
            {
              role: "function",
              name: response.choices[0].message.function_call.name,
              content: JSON.stringify(functionResult)
            }
          ],
        });
        
        // Return final response
        return {
          message: secondResponse.choices[0]?.message?.content,
          functionCall: {
            name: response.choices[0].message.function_call.name,
            arguments: JSON.parse(response.choices[0].message.function_call.arguments),
            result: functionResult
          }
        };
      }
      
      // Return direct response if no function call
      return {
        message: response.choices[0]?.message?.content
      };
    } catch (error) {
      console.error("Error in generateChatCompletion:", error);
      throw new Error(`Failed to generate response: ${error}`);
    }
  },
});
```

## Function Execution

When a function call is detected, the application:

1. Extracts the function name and arguments
2. Maps the function name to the appropriate Canvas API call
3. Executes the function with the provided arguments
4. Returns the result to be sent back to OpenAI

```typescript
// Example of function execution
switch (functionName) {
  case "get_courses":
    functionResult = await ctx.runAction(internal.canvas.getCourses, { 
      userId: args.userId 
    });
    break;
  case "get_assignments":
    functionResult = await ctx.runAction(internal.canvas.getAssignments, { 
      userId: args.userId,
      courseId: functionArgs.course_id
    });
    break;
  // Other functions...
}
```

## Message Storage

All messages, including function calls and their results, are stored in the database:

```typescript
// Save message with function call data
await ctx.runMutation(internal.messages.saveMessage, {
  chatId: args.chatId,
  userId: args.userId,
  content: finalMessage,
  role: "assistant",
  tokens: secondResponse.usage?.total_tokens || 0,
  functionCall: JSON.stringify({
    name: functionName,
    arguments: functionArgs,
    result: functionResult
  })
});
```

## Benefits of Function Calling

1. **Seamless Integration**: Users can ask about Canvas data naturally in conversation
2. **Context-Aware Responses**: The AI can access exactly the data needed to answer questions
3. **Structured Data Access**: Function calls provide a clear interface for accessing external data
4. **Reduced Hallucination**: The AI uses real data rather than making up answers

## Limitations and Considerations

1. **Rate Limiting**: Be aware of Canvas API rate limits when making frequent calls
2. **Error Handling**: Robust error handling is needed for API failures
3. **Authentication**: Ensure Canvas credentials are valid before attempting function calls
4. **Function Selection**: The AI may not always correctly identify when to use functions
5. **Response Formatting**: The AI needs to format technical data in a user-friendly way

## Future Improvements

1. **Additional Functions**: Add more Canvas API endpoints as functions
2. **Caching**: Implement caching for frequently accessed data
3. **Better Error Messages**: Improve user-facing error messages
4. **Stream Responses**: Use streaming for better user experience during API calls
5. **Function Parameters**: Enhance parameter validation and error handling
</file>

<file path="docs/ui-design.md">
# UI Design System & Chat Experience

## Overview

Canvas Manus implements a clean, minimal UI design inspired by Vercel's v0 interface while maintaining a distinct white background with black borders aesthetic. This document outlines the design principles, component styles, and interaction patterns used throughout the application.

## Design Principles

### 1. Visual Hierarchy

- **Primary Actions**: Black buttons with white text for high contrast
- **Secondary Actions**: Bordered buttons with black text
- **Tertiary Actions**: Text links and icon buttons
- **Information Hierarchy**: Clear typographic scale with proper heading levels

### 2. White Space & Rhythm

- Consistent spacing system using Tailwind's spacing scale
- Generous white space between sections to improve readability
- Controlled content density to prevent visual overwhelm

### 3. Typography

- Sans-serif typeface for optimal readability
- Font size scale: 0.75rem (xs) → 2rem (3xl)
- Proper line height: 1.5 for body text, 1.2 for headings
- Limited use of font weights: 400 (normal), 500 (medium), 600 (semibold)

### 4. Color System

- **Primary**: Black (#000000)
- **Background**: White (#FFFFFF)
- **Borders**: Black at different opacity levels (100%, 80%, 60%)
- **Text**: Black for maximum readability
- **Accents**: Grayscale palette for secondary elements
- **Status**: System colors for success, warning, error states

## Chat Experience

### Auto-Naming Chats

The application automatically names chats based on the first message content:

1. User sends first message in a new chat
2. System extracts key topics from message content
3. Chat title is automatically updated to reflect the conversation subject
4. User can manually edit title if desired

### Chat Flow & Interactions

#### 1. Dashboard Entry Points

- Quick "New Chat" button in dashboard header
- Chat creation card in empty state
- Recent chats list with direct links

#### 2. Chat Interface Components

- **Header**: 
  - Simple bar with chat title and emoji
  - Back button to return to dashboard
  - Action buttons for editing and deleting
  
- **Message List**:
  - Clean, alternating message bubbles
  - User messages right-aligned with subtle background
  - AI responses left-aligned with white background and black border
  - Date separators with calendar icon for context
  - Automatic scrolling to latest message

- **Message Actions**:
  - Copy button appears on hover
  - Like button for positive feedback
  - Timestamp display

- **Input Area**:
  - Full-width textarea with auto-resize
  - Send button transforms between states
  - Example prompts for new users
  - Clear visual separation with top border

## Micro-Interactions

### Animations & Transitions

- **Button Animations**: 
  - Scale effect on hover/press using Framer Motion
  - Smooth state transitions for loading indicators

- **Message Appearance**:
  - Staggered fade-in for message groups
  - Subtle slide-in for new messages

- **Page Transitions**:
  - Consistent entrance animations for major views
  - Fade transitions between pages

## Responsive Design

- Mobile-first approach with progressive enhancement
- Breakpoint system:
  - Mobile: 0-639px
  - Tablet: 640px-1023px
  - Desktop: 1024px+
- Adaptive layouts that maintain visual hierarchy across devices
- Touch-friendly targets (minimum 44x44px) for mobile users

## Accessibility Considerations

- Sufficient color contrast (4.5:1 minimum)
- Keyboard navigation support
- Focus indicators for interactive elements
- Screen reader-friendly element structure
- ARIA attributes where appropriate

## Implementation Guidelines

When implementing UI components, developers should:

1. Use the existing Tailwind utility classes
2. Maintain consistent spacing using the scale
3. Follow the established component patterns
4. Test interactions across devices
5. Ensure responsive behavior works as expected

The design system is implemented throughout the codebase with example components like `ChatContainer`, `Message`, and `MessageList` serving as reference implementations.
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="middleware.ts">
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';

// Create a route matcher for public routes
const isPublicRoute = createRouteMatcher([
  '/', 
  '/api/webhook', 
  '/pricing', 
  '/login', 
  '/sign-up',
  /^\/api(?:\/|$)/
]);

export default clerkMiddleware({
  // Return true for routes that don't require authentication
  publicRoutes: (req) => isPublicRoute(req)
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/(auth)/sign-in/page.tsx">
"use client";

import { SignIn } from "@clerk/nextjs";

export default function SignInPage() {
  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-50">
      <div className="w-full max-w-md p-8 space-y-8 bg-white shadow-lg rounded-lg">
        <div className="text-center mb-6">
          <h1 className="text-3xl font-bold text-black">Sign In</h1>
          <p className="mt-2 text-sm text-black">
            Welcome back! Please enter your details
          </p>
        </div>
        <SignIn
          appearance={{
            elements: {
              rootBox: "w-full",
              card: "shadow-none p-0 w-full",
            }
          }}
          redirectUrl="/dashboard"
        />
      </div>
    </div>
  );
}
</file>

<file path="src/app/(auth)/sign-up/page.tsx">
"use client";

import { SignUp } from "@clerk/nextjs";

export default function SignUpPage() {
  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-50">
      <div className="w-full max-w-md p-8 space-y-8 bg-white shadow-lg rounded-lg">
        <div className="text-center mb-6">
          <h1 className="text-3xl font-bold text-black">Sign Up</h1>
          <p className="mt-2 text-sm text-black">
            Create an account to get started
          </p>
        </div>
        <SignUp
          appearance={{
            elements: {
              rootBox: "w-full",
              card: "shadow-none p-0 w-full",
            }
          }}
          redirectUrl="/dashboard"
        />
      </div>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/chat/[id]/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useParams, useRouter } from "next/navigation";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../../convex/_generated/api";
import { Id } from "../../../../../convex/_generated/dataModel";
import { ChatContainer } from "@/app/components/chat/ChatContainer";
import { Loader2 } from "lucide-react";
import { Message } from "@/types/chat";

export default function ChatDetailPage() {
  const params = useParams();
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  
  // Safely get chatId from params
  const chatIdString = params?.id ? (params.id as string) : null;
  
  // Convert string chatId to Convex Id when available
  const convexChatId = chatIdString as unknown as Id<"chats"> | null;
  
  // Get chat details
  const chat = useQuery(
    api.chats.getChat, 
    convexChatId ? { chatId: convexChatId } : "skip"
  );
  
  // Get messages for this chat
  const messagesResult = useQuery(
    api.messages.getMessages, 
    convexChatId ? { chatId: convexChatId } : "skip"
  ) || [];
  
  // Send message mutation
  const sendMessage = useMutation(api.messages.sendMessage);
  
  // Update chat mutation
  const updateChat = useMutation(api.chats.updateChat);
  
  // Delete chat mutation
  const deleteChat = useMutation(api.chats.deleteChat);
  
  // Handle sending a new message
  const handleSendMessage = async (content: string) => {
    if (!convexChatId) return;
    
    try {
      setIsLoading(true);
      await sendMessage({
        chatId: convexChatId,
        content,
      });
      
      // If this is the first message and the chat doesn't have a title yet, 
      // set a title based on the content of the first message
      if (messagesResult.length === 0 && (!chat?.title || chat.title === "New Chat")) {
        // Create a title from the first message (truncate if too long)
        const autoTitle = content.length > 30 
          ? content.substring(0, 30) + "..." 
          : content;
          
        await updateChat({
          id: convexChatId,
          title: autoTitle
        });
      }
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle updating chat title
  const handleUpdateTitle = async (newTitle: string) => {
    if (!convexChatId) return;
    
    try {
      await updateChat({
        id: convexChatId,
        title: newTitle
      });
    } catch (error) {
      console.error("Failed to update chat title:", error);
    }
  };

  // Handle deleting chat
  const handleDeleteChat = async () => {
    if (!convexChatId) return;
    
    try {
      await deleteChat({
        chatId: convexChatId
      });
      router.push("/dashboard");
    } catch (error) {
      console.error("Failed to delete chat:", error);
    }
  };

  // If chatId is not available or loading, show loading state
  if (!chatIdString || !chat) {
    return (
      <div className="flex items-center justify-center h-screen bg-white">
        <Loader2 className="h-8 w-8 animate-spin text-black" />
      </div>
    );
  }

  return (
    <ChatContainer 
      messages={messagesResult as Message[]} 
      isLoading={isLoading}
      onSendMessage={handleSendMessage}
      title={chat.title}
      chatId={convexChatId ? convexChatId.toString() : undefined}
      onUpdateTitle={handleUpdateTitle}
      onDeleteChat={handleDeleteChat}
    />
  );
}
</file>

<file path="src/app/(dashboard)/chat/page.tsx">
"use client";

import { useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { MessageSquare, Plus, Sparkles } from "lucide-react";
import { motion } from "framer-motion";
import { Id } from "../../../../convex/_generated/dataModel";

export default function ChatPage() {
  const router = useRouter();
  const chats = useQuery(api.chats.getChats) || [];
  const createChat = useMutation(api.chats.createChat);
  const deleteChat = useMutation(api.chats.deleteChat);

  // Handle creating a new chat
  const handleNewChat = useCallback(async () => {
    try {
      // Create a new chat with a default title
      const chatId = await createChat({ title: "New Chat" });
      
      // Navigate to the new chat
      router.push(`/chat/${chatId}`);
    } catch (error) {
      console.error("Failed to create chat:", error);
      alert("Failed to create a new chat. Please try again.");
    }
  }, [createChat, router]);

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  // Example conversation starters
  const conversationStarters = [
    "Tell me about the history of artificial intelligence",
    "How can I improve my study habits?",
    "Explain quantum computing in simple terms",
    "What are the best strategies for time management?",
    "Help me understand machine learning algorithms",
    "Write a summary of climate change impacts"
  ];

  return (
    <motion.div 
      variants={container}
      initial="hidden"
      animate="show"
      className="h-full flex flex-col items-center justify-center p-4 md:p-8"
    >
      <motion.div variants={item} className="max-w-3xl w-full text-center mb-8">
        <div className="flex justify-center mb-6">
          <div className="w-20 h-20 bg-black rounded-full flex items-center justify-center">
            <MessageSquare className="h-10 w-10 text-white" />
          </div>
        </div>
        <h1 className="text-3xl font-bold mb-2">Start a new conversation</h1>
        <p className="text-black max-w-xl mx-auto">
          Chat with your AI assistant about anything. Ask questions, get explanations, or just have a conversation.
        </p>
      </motion.div>

      <motion.div variants={item} className="w-full max-w-3xl">
        <button
          onClick={handleNewChat}
          className="w-full py-4 px-6 bg-black text-white font-medium rounded-lg flex items-center justify-center gap-2 hover:bg-gray-800 transition-colors mb-8"
        >
          <Plus className="h-5 w-5" />
          New Conversation
        </button>

        <div className="mb-8">
          <h2 className="text-lg font-medium mb-4 text-center">Try asking about...</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {conversationStarters.map((starter, index) => (
              <motion.div
                key={index}
                variants={item}
                className="relative"
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
              >
                <button
                  onClick={() => {
                    handleNewChat().then(async () => {
                      // We would ideally want to pre-populate the new chat with this starter question
                      // This would require additional functionality in the API
                    });
                  }}
                  className="w-full text-left p-4 border border-black rounded-lg hover:bg-gray-50 transition-colors"
                >
                  <div className="flex items-start gap-3">
                    <Sparkles className="h-5 w-5 mt-0.5 text-black" />
                    <span className="font-medium">{starter}</span>
                  </div>
                </button>
              </motion.div>
            ))}
          </div>
        </div>

        {chats.length > 0 && (
          <motion.div variants={item} className="border-t border-gray-200 pt-8">
            <h2 className="text-lg font-medium mb-4">Recent conversations</h2>
            <div className="space-y-3">
              {chats.slice(0, 3).map((chat) => (
                <motion.div
                  key={chat._id}
                  whileHover={{ scale: 1.01 }}
                  whileTap={{ scale: 0.99 }}
                >
                  <button
                    onClick={() => router.push(`/chat/${chat._id}`)}
                    className="w-full text-left p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center">
                        <MessageSquare className="h-5 w-5 text-black" />
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-medium truncate">{chat.title || "New Chat"}</p>
                        <p className="text-sm text-black truncate">
                          {new Date(chat._creationTime).toLocaleDateString()}
                        </p>
                      </div>
                    </div>
                  </button>
                </motion.div>
              ))}
            </div>
          </motion.div>
        )}
      </motion.div>
    </motion.div>
  );
}
</file>

<file path="src/app/(dashboard)/dashboard/page.tsx">
"use client";

import { useUser } from "@clerk/nextjs";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { motion } from "framer-motion";
import { 
  MessageSquare, 
  User, 
  Sparkles, 
  Plus,
  BrainCircuit,
  BarChart3,
  Clock
} from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";

export default function DashboardPage() {
  const { user } = useUser();
  const convexUser = useQuery(api.users.getUser);
  const chats = useQuery(api.chats.getChats) || [];
  const createChat = useMutation(api.chats.createChat);
  const router = useRouter();

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };
  
  const handleNewChat = async () => {
    try {
      const chatId = await createChat({ title: "New Chat" });
      if (chatId) {
        router.push(`/chat/${chatId}`);
      }
    } catch (error) {
      console.error("Failed to create new chat:", error);
    }
  };

  return (
    <motion.div 
      variants={container}
      initial="hidden"
      animate="show"
      className="space-y-6"
    >
      <motion.div variants={item} className="bg-white shadow-sm border border-black rounded-lg p-6">
        <div className="flex items-center gap-4 mb-4">
          <div className="h-14 w-14 rounded-full bg-black flex items-center justify-center">
            <User className="h-8 w-8 text-white" />
          </div>
          <div>
            <h1 className="text-2xl font-bold text-black">Welcome back, {user?.firstName || "User"}!</h1>
            <p className="text-black">Your AI assistant is ready to help</p>
          </div>
        </div>
      </motion.div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <motion.div variants={item} className="md:col-span-2">
          <div className="bg-white shadow-sm border border-black rounded-lg p-6 h-full">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold text-black flex items-center gap-2">
                <MessageSquare className="h-5 w-5" />
                Recent Chats
              </h2>
              <Link 
                href="#" 
                onClick={(e) => {
                  e.preventDefault();
                  handleNewChat();
                }}
                className="text-sm text-black hover:text-gray-700 flex items-center gap-1"
              >
                <Plus className="h-4 w-4" />
                New Chat
              </Link>
            </div>
            
            {chats.length > 0 ? (
              <div className="space-y-3">
                {chats.slice(0, 5).map((chat) => (
                  <Link 
                    key={chat._id} 
                    href={`/chat/${chat._id}`} 
                    className="flex items-center gap-3 p-3 rounded-lg border border-black hover:bg-gray-50 transition-colors"
                  >
                    <div className="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center">
                      <MessageSquare className="h-5 w-5 text-black" />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-black truncate">{chat.title || "New Chat"}</p>
                      <p className="text-sm text-black truncate">
                        {new Date(chat._creationTime).toLocaleDateString()}
                      </p>
                    </div>
                    <div className="flex items-center justify-center">
                      <Clock className="h-4 w-4 text-black" />
                      <span className="text-xs text-black ml-1">
                        {new Date(chat._creationTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                      </span>
                    </div>
                  </Link>
                ))}
              </div>
            ) : (
              <div className="text-center p-8">
                <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-gray-100 mb-4">
                  <MessageSquare className="h-8 w-8 text-black" />
                </div>
                <p className="text-black mb-4">You haven't started any chats yet.</p>
                <motion.button 
                  onClick={handleNewChat}
                  className="inline-flex items-center gap-2 px-4 py-2 rounded-md bg-black text-white hover:bg-gray-800 transition-colors"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Plus className="h-4 w-4" />
                  Start a New Chat
                </motion.button>
              </div>
            )}
          </div>
        </motion.div>
        
        <motion.div variants={item} className="space-y-6">
          <div className="bg-white shadow-sm border border-black rounded-lg p-6">
            <h2 className="text-xl font-bold text-black flex items-center gap-2 mb-4">
              <User className="h-5 w-5" />
              Account Info
            </h2>
            <div className="space-y-3">
              <div className="flex justify-between items-center">
                <span className="text-black">Email</span>
                <span className="text-black">{user?.emailAddresses[0].emailAddress}</span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-black">Plan</span>
                <span className="text-black">{convexUser?.plan || "Free"}</span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-black">Credits</span>
                <span className="text-black">{convexUser?.credits || 0}</span>
              </div>
            </div>
          </div>
          
          <div className="bg-white shadow-sm border border-black rounded-lg p-6">
            <h2 className="text-xl font-bold text-black flex items-center gap-2 mb-4">
              <BarChart3 className="h-5 w-5" />
              Usage
            </h2>
            <div className="space-y-4">
              <div>
                <div className="flex justify-between items-center mb-1">
                  <span className="text-black">Tokens Used</span>
                  <span className="text-black">2012 / 5000</span>
                </div>
                <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-black rounded-full" 
                    style={{ width: `${Math.min(((convexUser?.usageTokens || 0) / 5000) * 100, 100)}%` }}
                  ></div>
                </div>
              </div>
              <div>
                <div className="flex justify-between items-center mb-1">
                  <span className="text-black">Chats Created</span>
                  <span className="text-black">{chats.length}</span>
                </div>
              </div>
            </div>
          </div>
        </motion.div>
      </div>
    </motion.div>
  );
}
</file>

<file path="src/app/components/animations.tsx">
"use client";

import { motion } from 'framer-motion';
import { ReactNode } from 'react';

type FadeInProps = {
  children: ReactNode;
  delay?: number;
  duration?: number;
  className?: string;
};

export const FadeIn = ({ children, delay = 0, duration = 0.6, className = '' }: FadeInProps) => (
  <motion.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    transition={{ duration, delay }}
    className={className}
  >
    {children}
  </motion.div>
);

type FloatingElementProps = {
  children: ReactNode;
  amount?: number;
  duration?: number;
  className?: string;
};

export const FloatingElement = ({ children, amount = 10, duration = 4, className = '' }: FloatingElementProps) => (
  <motion.div
    animate={{ 
      y: [0, -amount, 0],
    }}
    transition={{ 
      duration,
      repeat: Infinity,
      ease: "easeInOut" 
    }}
    className={className}
  >
    {children}
  </motion.div>
);

type GradientTextProps = {
  children: ReactNode;
  className?: string;
}

export const GradientText = ({ children, className = '' }: GradientTextProps) => (
  <motion.span
    className={`bg-gradient-to-r from-black to-black dark:from-white dark:to-white bg-clip-text text-transparent ${className}`}
    initial={{ backgroundPosition: "0% 50%" }}
    whileHover={{ scale: 1.05 }}
  >
    {children}
  </motion.span>
);

// New animation components for more micro-interactions

type RevealProps = {
  children: ReactNode;
  direction?: 'left' | 'right' | 'up' | 'down';
  delay?: number;
  className?: string;
};

export const Reveal = ({ children, direction = 'up', delay = 0, className = '' }: RevealProps) => {
  const directionMap = {
    left: { x: -50, y: 0 },
    right: { x: 50, y: 0 },
    up: { x: 0, y: 50 },
    down: { x: 0, y: -50 }
  };

  return (
    <motion.div
      initial={{ opacity: 0, ...directionMap[direction] }}
      whileInView={{ opacity: 1, x: 0, y: 0 }}
      viewport={{ once: true, margin: "-100px" }}
      transition={{ duration: 0.7, delay }}
      className={className}
    >
      {children}
    </motion.div>
  );
};

type TypewriterProps = {
  text: string;
  delay?: number;
  className?: string;
};

export const Typewriter = ({ text, delay = 0, className = '' }: TypewriterProps) => (
  <motion.div
    className={className}
    initial={{ opacity: 1 }}
    animate={{ opacity: 1 }}
    transition={{ delay }}
  >
    {text.split('').map((char, index) => (
      <motion.span
        key={index}
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: delay + index * 0.05 }}
      >
        {char}
      </motion.span>
    ))}
  </motion.div>
);
</file>

<file path="src/app/components/chat/ChatList.tsx">
"use client";

import { useCallback } from "react";
import Link from "next/link";
import { usePathname, useRouter } from "next/navigation";
import { MessageSquare, Plus, Trash } from "lucide-react";
import { useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { motion } from "framer-motion";

type ChatType = {
  _id: string;
  title: string;
  updatedAt: number;
};

type ChatListProps = {
  chats: ChatType[];
  onDeleteChat: (chatId: string) => void;
};

export function ChatList({ chats, onDeleteChat }: ChatListProps) {
  const pathname = usePathname();
  const router = useRouter();
  const createChat = useMutation(api.chats.createChat);
  
  const handleNewChat = async () => {
    // Create a new chat and navigate to it
    try {
      const chatId = await createChat({ title: "New Chat" });
      if (chatId) {
        router.push(`/chat/${chatId}`);
      }
    } catch (error) {
      console.error("Failed to create new chat:", error);
    }
  };
  
  const handleDelete = useCallback((e: React.MouseEvent, chatId: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Confirm before deleting
    if (confirm("Are you sure you want to delete this chat?")) {
      onDeleteChat(chatId);
    }
  }, [onDeleteChat]);

  return (
    <div className="w-full h-full flex flex-col bg-gray-50 border-r border-black">
      <div className="p-4">
        <motion.button
          onClick={handleNewChat}
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
          className="w-full flex items-center justify-center gap-2 bg-black text-white py-2 px-4 rounded-lg hover:bg-gray-800 transition-colors"
        >
          <Plus size={16} />
          <span>New Chat</span>
        </motion.button>
      </div>

      {/* Chat list */}
      <div className="flex-1 overflow-y-auto">
        <div className="px-2 py-3">
          <h3 className="px-2 text-xs font-medium text-black uppercase tracking-wider">
            Your Chats
          </h3>
          <div className="mt-2 space-y-1">
            {chats.length === 0 ? (
              <div className="p-3 text-center text-sm text-black">
                No chats yet. Start a new conversation!
              </div>
            ) : (
              chats.map((chat) => {
                const isActive = pathname === `/chat/${chat._id}`;
                return (
                  <Link
                    key={chat._id}
                    href={`/chat/${chat._id}`}
                    className={`flex items-center justify-between p-2 rounded-md ${
                      isActive
                        ? "bg-gray-200 text-black font-medium"
                        : "hover:bg-gray-100 text-black"
                    }`}
                  >
                    <div className="flex items-center gap-3 truncate">
                      <MessageSquare size={16} />
                      <span className="truncate text-sm">
                        {chat.title || "New Chat"}
                      </span>
                    </div>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDelete(e, chat._id);
                      }}
                      className="ml-2 p-1 text-black hover:text-red-600 rounded-md hover:bg-gray-200 transition-colors"
                      aria-label="Delete chat"
                    >
                      <Trash size={16} />
                    </button>
                  </Link>
                );
              })
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/components/chat/FunctionCallResult.tsx">
"use client";

import React from 'react';

type FunctionCallProps = {
  functionCall: {
    name: string;
    arguments: any;
    result: any;
  };
};

export function FunctionCallResult({ functionCall }: FunctionCallProps) {
  const formatFunctionName = (name: string) => {
    return name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };
  
  const renderCourses = (courses: any[]) => {
    if (!Array.isArray(courses) || courses.length === 0) {
      return <p className="text-gray-500">No courses found</p>;
    }
    
    return (
      <div className="mt-2">
        <h4 className="font-bold">Your Courses:</h4>
        <ul className="list-disc pl-5 mt-1">
          {courses.map((course) => (
            <li key={course.id} className="mb-1">
              <span className="font-medium">{course.name}</span> 
              <span className="text-xs text-gray-500 ml-1">(ID: {course.id})</span>
            </li>
          ))}
        </ul>
      </div>
    );
  };
  
  const renderAssignments = (assignments: any[]) => {
    if (!Array.isArray(assignments) || assignments.length === 0) {
      return <p className="text-gray-500">No assignments found</p>;
    }
    
    return (
      <div className="mt-2">
        <h4 className="font-bold">Assignments:</h4>
        <ul className="list-disc pl-5 mt-1">
          {assignments.map((assignment) => (
            <li key={assignment.id} className="mb-1">
              <span className="font-medium">{assignment.name}</span>
              {assignment.due_at && (
                <span className="text-xs text-gray-500 ml-1">
                  Due: {new Date(assignment.due_at).toLocaleDateString()}
                </span>
              )}
            </li>
          ))}
        </ul>
      </div>
    );
  };
  
  const renderAnnouncements = (announcements: any[]) => {
    if (!Array.isArray(announcements) || announcements.length === 0) {
      return <p className="text-gray-500">No announcements found</p>;
    }
    
    return (
      <div className="mt-2">
        <h4 className="font-bold">Announcements:</h4>
        <ul className="list-disc pl-5 mt-1">
          {announcements.map((announcement) => (
            <li key={announcement.id} className="mb-1">
              <span className="font-medium">{announcement.title}</span>
              {announcement.posted_at && (
                <span className="text-xs text-gray-500 ml-1">
                  Posted: {new Date(announcement.posted_at).toLocaleDateString()}
                </span>
              )}
            </li>
          ))}
        </ul>
      </div>
    );
  };
  
  const renderModules = (modules: any[]) => {
    if (!Array.isArray(modules) || modules.length === 0) {
      return <p className="text-gray-500">No modules found</p>;
    }
    
    return (
      <div className="mt-2">
        <h4 className="font-bold">Modules:</h4>
        <ul className="list-disc pl-5 mt-1">
          {modules.map((module) => (
            <li key={module.id} className="mb-1">
              <span className="font-medium">{module.name}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  };
  
  const renderFunctionResult = () => {
    const { name, result } = functionCall;
    
    if (result.error) {
      return (
        <div className="text-red-500">
          Error: {result.error}
        </div>
      );
    }
    
    switch (name) {
      case "get_courses":
        return renderCourses(result);
      case "get_assignments":
        return renderAssignments(result);
      case "get_announcements":
        return renderAnnouncements(result);
      case "get_modules":
        return renderModules(result);
      default:
        return (
          <pre className="bg-gray-100 p-2 rounded text-sm overflow-auto">
            {JSON.stringify(result, null, 2)}
          </pre>
        );
    }
  };
  
  return (
    <div className="border border-gray-200 rounded-md p-3 bg-gray-50 my-2">
      <div className="font-medium text-gray-700">
        {formatFunctionName(functionCall.name)}
      </div>
      {renderFunctionResult()}
    </div>
  );
}
</file>

<file path="src/app/components/chat/MessageInput.tsx">
"use client";

import { useState, useRef, useEffect } from "react";
import { Send, Loader2, Smile, Paperclip } from "lucide-react";
import { motion } from "framer-motion";

type MessageInputProps = {
  onSendMessage: (content: string) => void;
  isLoading?: boolean;
  placeholder?: string;
};

export function MessageInput({ 
  onSendMessage, 
  isLoading = false, 
  placeholder = "Type your message..." 
}: MessageInputProps) {
  const [message, setMessage] = useState("");
  const [isFocused, setIsFocused] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Common emoji sets
  const quickEmojis = ["😊", "👍", "🙏", "❤️", "😂", "🎉", "👀", "🤔"];

  // Resize textarea as content grows
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
    }
  }, [message]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!message.trim() || isLoading) return;
    
    onSendMessage(message);
    setMessage("");
    
    // Reset textarea height
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  const addEmoji = (emoji: string) => {
    setMessage(prev => prev + emoji);
    if (textareaRef.current) {
      textareaRef.current.focus();
    }
  };

  return (
    <div className="border-t border-gray-200 bg-white p-4 shadow-md">
      <motion.form 
        onSubmit={handleSubmit} 
        className="flex flex-col space-y-2 max-w-4xl mx-auto"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
      >
        <div className="flex items-center gap-1.5 mb-1 px-1">
          {quickEmojis.map(emoji => (
            <motion.button
              key={emoji}
              type="button"
              onClick={() => addEmoji(emoji)}
              className="text-lg opacity-80 hover:opacity-100 focus:outline-none"
              whileHover={{ scale: 1.2 }}
              whileTap={{ scale: 0.95 }}
            >
              {emoji}
            </motion.button>
          ))}
          <div className="flex-1"></div>
          <button
            type="button"
            className="p-1.5 text-black hover:text-indigo-600 rounded-full transition-colors hover:bg-indigo-50"
          >
            <Smile size={18} />
          </button>
          <button
            type="button"
            className="p-1.5 text-black hover:text-indigo-600 rounded-full transition-colors hover:bg-indigo-50"
          >
            <Paperclip size={18} />
          </button>
        </div>
        
        <div className="flex items-end gap-3">
          <motion.div 
            className={`flex-1 relative rounded-xl border ${
              isFocused 
                ? "border-indigo-300 ring-2 ring-indigo-100" 
                : "border-gray-300 hover:border-gray-400"
            } transition-all duration-200 bg-white overflow-hidden shadow-sm`}
            animate={{ boxShadow: isFocused ? "0 2px 8px rgba(99, 102, 241, 0.15)" : "0 1px 2px rgba(0, 0, 0, 0.05)" }}
          >
            <textarea
              ref={textareaRef}
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyDown={handleKeyDown}
              onFocus={() => setIsFocused(true)}
              onBlur={() => setIsFocused(false)}
              placeholder={placeholder}
              rows={1}
              className="w-full resize-none py-3 px-4 text-black focus:outline-none bg-transparent"
              disabled={isLoading}
            />
          </motion.div>
          
          <motion.button
            type="submit"
            disabled={!message.trim() || isLoading}
            className={`rounded-full p-3.5 flex items-center justify-center ${
              message.trim() && !isLoading
                ? "bg-indigo-600 text-white hover:bg-indigo-700" 
                : "bg-gray-100 text-black cursor-not-allowed"
            } focus:outline-none transition-all duration-200`}
            whileHover={message.trim() && !isLoading ? { scale: 1.05 } : {}}
            whileTap={message.trim() && !isLoading ? { scale: 0.95 } : {}}
          >
            {isLoading ? (
              <Loader2 size={20} className="animate-spin" />
            ) : (
              <Send size={20} />
            )}
          </motion.button>
        </div>
      </motion.form>
      
      <p className="text-xs text-center mt-2 text-black">
        Press Shift + Enter for a new line • Click an emoji to add it
      </p>
    </div>
  );
}
</file>

<file path="src/app/components/logo.tsx">
"use client";

import React from 'react';

export function Logo({ className = '', size = 32 }) {
  return (
    <svg 
      width={size} 
      height={size} 
      viewBox="0 0 32 32" 
      className={className}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
    >
      <rect width="32" height="32" rx="4" className="fill-black dark:fill-white" />
      <path 
        d="M7 8H25M7 14H18M7 20H22" 
        className="stroke-white dark:stroke-black" 
        strokeWidth="2" 
        strokeLinecap="round"
      />
      <circle 
        cx="22" 
        cy="14" 
        r="3" 
        className="stroke-white dark:stroke-black" 
        strokeWidth="2" 
      />
    </svg>
  );
}

export function LogoText({ className = '' }) {
  return (
    <div className={`font-bold text-xl flex items-center ${className}`}>
      <Logo size={24} className="mr-2" />
      <span>Studi</span>
    </div>
  );
}
</file>

<file path="src/app/components/pricing.tsx">
"use client";

import { useState } from 'react';
import { FadeIn, Reveal } from './animations';
import Link from 'next/link';

// Feature check SVG component
const CheckIcon = () => (
  <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path 
      d="M7.5 13.5L4 10L3 11L7.5 15.5L17.5 5.5L16.5 4.5L7.5 13.5Z" 
      fill="currentColor" 
    />
  </svg>
);

// Pricing data
const pricingPlans = [
  {
    id: 'free',
    name: 'Student Basic',
    price: '0',
    description: 'Perfect for individual students just getting started.',
    features: [
      'Canvas course integration',
      'Basic AI homework help',
      'Assignment tracking',
      'Single user access',
      'Limited summarizations (5/month)'
    ],
    cta: 'Start Free',
    popular: false
  },
  {
    id: 'pro',
    name: 'Student Pro',
    price: '9',
    description: 'For dedicated students who want to excel in their courses.',
    features: [
      'Full Canvas integration',
      'Advanced AI homework assistance',
      'Unlimited summarizations',
      'Study plan generation',
      'Exam preparation help',
      'Grade improvement insights',
      'Priority support',
      'All file formats supported'
    ],
    cta: 'Start Free Trial',
    popular: true
  },
  {
    id: 'team',
    name: 'Study Group',
    price: '19',
    description: 'For study groups that want to collaborate and excel together.',
    features: [
      'Everything in Student Pro',
      'Up to 5 student accounts',
      'Collaborative study plans',
      'Shared notes & materials',
      'Group assignment tracking',
      'Discussion tools',
      'Group performance analytics',
      'Dedicated support'
    ],
    cta: 'Get Started',
    popular: false
  }
];

export function Pricing() {
  const [annualBilling, setAnnualBilling] = useState(true);
  
  return (
    <section id="pricing" className="py-24">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Section header */}
        <div className="max-w-3xl mx-auto text-center mb-16">
          <Reveal>
            <h2 className="text-3xl md:text-4xl font-bold mb-4">Student-Friendly Pricing</h2>
          </Reveal>
          <FadeIn>
            <p className="text-lg opacity-80 mb-8">
              Affordable plans designed specifically for students. Start free and upgrade when you're ready.
            </p>
            
            {/* Billing toggle */}
            <div className="flex items-center justify-center space-x-4 mb-8">
              <span className={`text-sm ${!annualBilling ? 'font-medium' : 'opacity-60'}`}>Monthly</span>
              <button
                onClick={() => setAnnualBilling(!annualBilling)}
                className={`relative inline-flex h-6 w-12 shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus-visible:ring-2 focus-visible:ring-black dark:focus-visible:ring-white ${
                  annualBilling ? 'bg-black dark:bg-white' : 'bg-black/20 dark:bg-white/20'
                }`}
                role="switch"
                aria-checked={annualBilling}
              >
                <span className="sr-only">Toggle billing frequency</span>
                <span
                  aria-hidden="true"
                  className={`pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white dark:bg-black shadow-lg ring-0 transition duration-200 ease-in-out ${
                    annualBilling ? 'translate-x-6' : 'translate-x-0'
                  }`}
                />
              </button>
              <span className={`text-sm flex items-center ${annualBilling ? 'font-medium' : 'opacity-60'}`}>
                Yearly <span className="ml-1.5 px-1.5 py-0.5 text-xs rounded-full bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-100">Student Discount</span>
              </span>
            </div>
          </FadeIn>
        </div>

        {/* Pricing cards */}
        <div className="grid md:grid-cols-3 gap-8">
          {pricingPlans.map((plan, index) => (
            <FadeIn 
              key={plan.id}
              delay={index * 0.1} 
              className={`rounded-2xl shadow-sm overflow-hidden border ${
                plan.popular 
                  ? 'border-black dark:border-white' 
                  : 'border-black/10 dark:border-white/10'
              } flex flex-col`}
            >
              {plan.popular && (
                <div className="bg-black text-white dark:bg-white dark:text-black py-1.5 px-4 text-xs font-medium text-center">
                  Most Popular
                </div>
              )}
              
              <div className="px-6 py-8 flex-1">
                <h3 className="text-xl font-bold">{plan.name}</h3>
                <div className="mt-4 flex items-baseline">
                  <span className="text-4xl font-extrabold">${annualBilling ? (parseFloat(plan.price) * 0.8 * 12).toFixed(0) : plan.price}</span>
                  <span className="ml-1 text-lg text-black/60 dark:text-white/60">/{annualBilling ? 'year' : 'month'}</span>
                </div>
                <p className="mt-5 text-sm opacity-70">{plan.description}</p>
                
                <ul className="mt-6 space-y-4">
                  {plan.features.map((feature) => (
                    <li key={feature} className="flex items-center">
                      <div className="flex-shrink-0 w-5 h-5 flex items-center justify-center text-black dark:text-white">
                        <CheckIcon />
                      </div>
                      <span className="ml-3 text-sm">{feature}</span>
                    </li>
                  ))}
                </ul>
              </div>
              
              <div className="px-6 py-8 bg-black/5 dark:bg-white/5">
                <Link
                  href={`/signup?plan=${plan.id}`}
                  className={`w-full flex items-center justify-center px-4 py-3 rounded-full text-sm font-medium transition-colors ${
                    plan.popular
                      ? 'bg-black text-white dark:bg-white dark:text-black hover:opacity-90'
                      : 'border border-black dark:border-white hover:bg-black/5 dark:hover:bg-white/5'
                  }`}
                >
                  {plan.cta}
                </Link>
              </div>
            </FadeIn>
          ))}
        </div>
        
        {/* Educational discount info */}
        <div className="mt-16 text-center">
          <FadeIn>
            <p className="text-sm opacity-70">
              Special discounts available for educational institutions.{' '}
              <Link href="/edu-discount" className="font-medium underline hover:opacity-80">
                Learn about our educational program
              </Link>
            </p>
          </FadeIn>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

/* Base theme variables */
:root {
  --background: #ffffff;
  --foreground: #171717;
  --primary: #000000;
  --primary-foreground: #ffffff;
  --secondary: #f3f4f6;
  --secondary-foreground: #111827;
  --accent: #000000;
  --accent-foreground: #ffffff;
  --muted: #f3f4f6;
  --muted-foreground: #6b7280;
  --card: #ffffff;
  --card-foreground: #171717;
  --border: #e5e7eb;
  --input: #e5e7eb;
  --focus-ring: rgba(0, 0, 0, 0.2);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-inter);
}

/* Dark mode overrides */
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
    --primary: #ffffff;
    --primary-foreground: #000000;
    --secondary: #1f2937;
    --secondary-foreground: #f3f4f6;
    --accent: #ffffff;
    --accent-foreground: #000000;
    --muted: #1f2937;
    --muted-foreground: #9ca3af;
    --card: #0a0a0a;
    --card-foreground: #ededed;
    --border: #374151;
    --input: #374151;
    --focus-ring: rgba(255, 255, 255, 0.2);
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-sans);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Animations */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes highlight {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Utility classes */
.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-pulse-slow {
  animation: pulse 3s ease-in-out infinite;
}

.gradient-text {
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  background-size: 200% 200%;
  animation: highlight 4s ease infinite;
}

/* Improved focus styles */
*:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
}

/* Smooth scrolling */
html {
  scroll-behavior: smooth;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";

const inter = Inter({
  subsets: ["latin"],
  display: "swap",
  variable: "--font-inter",
});

export const metadata: Metadata = {
  title: "Studi - Your Canvas LMS AI Assistant",
  description: "Studi seamlessly integrates with Canvas LMS to help students manage their academic workload, understand course materials, and excel in their studies.",
  icons: {
    icon: "/favicon.ico",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="scroll-smooth">
      <body className={`${inter.variable} font-sans antialiased`}>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import { Navigation } from './components/navigation';
import { Hero } from './components/hero';
import { Features } from './components/features';
import { Testimonials } from './components/testimonials';
import { Pricing } from './components/pricing';
import { CTA } from './components/cta';
import { Footer } from './components/footer';
import { AuthCheck } from './components/auth/auth-check';

export default function Home() {
  return (
    <main>
      <AuthCheck />
      <Navigation />
      <Hero />
      <Features />
      <Testimonials />
      <Pricing />
      <CTA />
      <Footer />
    </main>
  );
}
</file>

<file path="src/app/providers.tsx">
"use client";

import { ClerkProvider, useAuth } from "@clerk/nextjs";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { ConvexReactClient } from "convex/react";

// Initialize the Convex client
const convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL!;
const convex = new ConvexReactClient(convexUrl);

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ClerkProvider publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}>
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        {children}
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
}
</file>

<file path="src/utils/logger.ts">
/**
 * Logger utility for consistent logging across the application
 * Supports different log levels and context tagging
 */

type LogLevel = 'debug' | 'info' | 'warn' | 'error';
type LogContext = 'app' | 'api' | 'chat' | 'ui' | 'canvas' | 'auth' | string;

interface LogOptions {
  level?: LogLevel;
  context?: LogContext;
}

// Controls which log levels are displayed in different environments
const LOG_LEVEL_PRIORITIES: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

// Current environment log level
const CURRENT_LOG_LEVEL = process.env.NODE_ENV === 'production' ? 'info' : 'debug';

// Format the log message with timestamp and context
const formatLogMessage = (
  message: string,
  data?: any,
  level: LogLevel = 'info',
  context: LogContext = 'app'
): string => {
  const timestamp = new Date().toISOString();
  const contextTag = context ? `[${context}]` : '';
  const levelTag = `[${level.toUpperCase()}]`;
  
  let formattedMessage = `${timestamp} ${levelTag} ${contextTag} ${message}`;
  
  if (data) {
    try {
      // Format data nicely if it's an object, otherwise just append
      if (typeof data === 'object' && data !== null) {
        formattedMessage += `\n${JSON.stringify(data, null, 2)}`;
      } else {
        formattedMessage += ` ${data}`;
      }
    } catch (error) {
      formattedMessage += ` [Failed to stringify data]`;
    }
  }
  
  return formattedMessage;
};

// Check if the log should be displayed based on priority
const shouldLog = (level: LogLevel): boolean => {
  return LOG_LEVEL_PRIORITIES[level] >= LOG_LEVEL_PRIORITIES[CURRENT_LOG_LEVEL as LogLevel];
};

// Core log function
const log = (
  level: LogLevel,
  message: string,
  data?: any,
  context: LogContext = 'app'
): void => {
  if (!shouldLog(level)) return;
  
  const formattedMessage = formatLogMessage(message, data, level, context);
  
  switch (level) {
    case 'debug':
      console.debug(formattedMessage);
      break;
    case 'info':
      console.info(formattedMessage);
      break;
    case 'warn':
      console.warn(formattedMessage);
      break;
    case 'error':
      console.error(formattedMessage);
      break;
    default:
      console.log(formattedMessage);
  }
};

// Public logger API
export const logger = {
  debug: (message: string, data?: any, context: LogContext = 'app') => 
    log('debug', message, data, context),
    
  info: (message: string, data?: any, context: LogContext = 'app') => 
    log('info', message, data, context),
    
  warn: (message: string, data?: any, context: LogContext = 'app') => 
    log('warn', message, data, context),
    
  error: (message: string, data?: any, context: LogContext = 'app') => 
    log('error', message, data, context),
};

// Also export the raw log function
export { log };
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require('@tailwindcss/typography'),
  ],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="utils/logger.ts">
// utils/logger.ts
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogDetails {
  message: string;
  data?: any;
  source?: string;
  timestamp?: Date;
  userId?: string;
}

class Logger {
  private static instance: Logger;
  private isDevelopment: boolean;

  private constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development';
  }

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  private log(level: LogLevel, details: LogDetails) {
    const timestamp = details.timestamp || new Date();
    const formattedMessage = `[${timestamp.toISOString()}] [${level.toUpperCase()}] ${details.source ? `[${details.source}]` : ''} ${details.message}`;
    
    // In development, log to console with color coding
    if (this.isDevelopment) {
      const colors = {
        debug: '\x1b[34m', // blue
        info: '\x1b[32m',  // green
        warn: '\x1b[33m',  // yellow
        error: '\x1b[31m'  // red
      };
      
      console[level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log'](
        `${colors[level]}${formattedMessage}\x1b[0m`,
        details.data ? details.data : ''
      );
    } else {
      // In production, you might want to send logs to a service
      console[level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log'](
        formattedMessage,
        details.data ? details.data : ''
      );
    }
  }

  debug(message: string, data?: any, source?: string) {
    this.log('debug', { message, data, source });
  }

  info(message: string, data?: any, source?: string) {
    this.log('info', { message, data, source });
  }

  warn(message: string, data?: any, source?: string) {
    this.log('warn', { message, data, source });
  }

  error(message: string, data?: any, source?: string) {
    this.log('error', { message, data, source });
  }
}

export const logger = Logger.getInstance();
</file>

<file path="convex/_generated/api.d.ts">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as canvas from "../canvas.js";
import type * as chats from "../chats.js";
import type * as index from "../index.js";
import type * as messages from "../messages.js";
import type * as openai from "../openai.js";
import type * as users from "../users.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  canvas: typeof canvas;
  chats: typeof chats;
  index: typeof index;
  messages: typeof messages;
  openai: typeof openai;
  users: typeof users;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;
</file>

<file path="convex/canvas.ts">
import { v } from "convex/values";
import { internalAction } from "./_generated/server";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// Type definitions for better type safety
type User = {
  _id: Id<"users">;
  canvasAccessToken?: string;
  canvasUrl?: string;
  [key: string]: any;
};

type CanvasResponse<T> = {
  success: boolean;
  data?: T;
  error?: string;
};

// Fetch Canvas courses for the user
export const getCourses = internalAction({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      // Get user information
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      // Construct API URL
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses?enrollment_state=active`;
      
      // Make API request to Canvas
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const courses = await response.json();
      return { success: true, data: courses };
    } catch (error) {
      console.error("Error fetching Canvas courses:", error);
      return { success: false, error: `Failed to fetch courses: ${error}` };
    }
  },
});

// Fetch assignments for a specific course
export const getAssignments = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      // Get user information
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      // Construct API URL
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/assignments`;
      
      // Make API request to Canvas
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const assignments = await response.json();
      return { success: true, data: assignments };
    } catch (error) {
      console.error("Error fetching Canvas assignments:", error);
      return { success: false, error: `Failed to fetch assignments: ${error}` };
    }
  },
});

// Fetch announcements for a specific course
export const getAnnouncements = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      // Get user information
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      // Construct API URL
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/discussion_topics?only_announcements=true`;
      
      // Make API request to Canvas
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const announcements = await response.json();
      return { success: true, data: announcements };
    } catch (error) {
      console.error("Error fetching Canvas announcements:", error);
      return { success: false, error: `Failed to fetch announcements: ${error}` };
    }
  },
});

// Fetch modules for a specific course
export const getModules = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      // Get user information
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      // Construct API URL
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/modules`;
      
      // Make API request to Canvas
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const modules = await response.json();
      return { success: true, data: modules };
    } catch (error) {
      console.error("Error fetching Canvas modules:", error);
      return { success: false, error: `Failed to fetch modules: ${error}` };
    }
  },
});

// Fetch files for a specific course
export const getFiles = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      // Get user information
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      // Construct API URL
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/files`;
      
      // Make API request to Canvas
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const files = await response.json();
      return { success: true, data: files };
    } catch (error) {
      console.error("Error fetching Canvas files:", error);
      return { success: false, error: `Failed to fetch files: ${error}` };
    }
  },
});

// Download a specific file
export const getFileDownloadUrl = internalAction({
  args: {
    userId: v.id("users"),
    fileId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<string>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/files/${args.fileId}`;
      
      // First get the file info
      const infoResponse = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!infoResponse.ok) {
        const errorText = await infoResponse.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const fileInfo = await infoResponse.json();
      
      // Get the download URL
      const downloadUrl = fileInfo.url;
      return { success: true, data: downloadUrl };
    } catch (error) {
      console.error("Error getting Canvas file download URL:", error);
      return { success: false, error: `Failed to get file download URL: ${error}` };
    }
  },
});

// Get grades for a user in a course
export const getCourseGrades = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/assignments?include[]=submission`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const grades = await response.json();
      return { success: true, data: grades };
    } catch (error) {
      console.error("Error fetching Canvas grades:", error);
      return { success: false, error: `Failed to fetch grades: ${error}` };
    }
  },
});

// Get the user's enrollment grades (overall course grades)
export const getEnrollmentGrades = internalAction({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/users/self/enrollments?include[]=grades`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const enrollments = await response.json();
      return { success: true, data: enrollments };
    } catch (error) {
      console.error("Error fetching Canvas enrollment grades:", error);
      return { success: false, error: `Failed to fetch enrollment grades: ${error}` };
    }
  },
});

// Get all discussions for a course
export const getDiscussions = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/discussion_topics`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const discussions = await response.json();
      return { success: true, data: discussions };
    } catch (error) {
      console.error("Error fetching Canvas discussions:", error);
      return { success: false, error: `Failed to fetch discussions: ${error}` };
    }
  },
});

// Get a specific discussion with entries/replies
export const getDiscussionDetails = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
    discussionId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/discussion_topics/${args.discussionId}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const discussionDetails = await response.json();
      return { success: true, data: discussionDetails };
    } catch (error) {
      console.error("Error fetching Canvas discussion details:", error);
      return { success: false, error: `Failed to fetch discussion details: ${error}` };
    }
  },
});

// Get user profile information
export const getUserProfile = internalAction({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/users/self/profile`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const profile = await response.json();
      return { success: true, data: profile };
    } catch (error) {
      console.error("Error fetching Canvas user profile:", error);
      return { success: false, error: `Failed to fetch user profile: ${error}` };
    }
  },
});

// Get user enrollments (courses they're enrolled in with roles)
export const getUserEnrollments = internalAction({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/users/self/enrollments`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const enrollments = await response.json();
      return { success: true, data: enrollments };
    } catch (error) {
      console.error("Error fetching Canvas user enrollments:", error);
      return { success: false, error: `Failed to fetch user enrollments: ${error}` };
    }
  },
});

// Get calendar events
export const getCalendarEvents = internalAction({
  args: {
    userId: v.id("users"),
    startDate: v.optional(v.string()), // Format: YYYY-MM-DD
    endDate: v.optional(v.string()),   // Format: YYYY-MM-DD
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      let url = `${baseUrl}api/v1/calendar_events`;
      
      // Add date parameters if provided
      const params = new URLSearchParams();
      if (args.startDate) params.append('start_date', args.startDate);
      if (args.endDate) params.append('end_date', args.endDate);
      if (params.toString()) url += `?${params.toString()}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const events = await response.json();
      return { success: true, data: events };
    } catch (error) {
      console.error("Error fetching Canvas calendar events:", error);
      return { success: false, error: `Failed to fetch calendar events: ${error}` };
    }
  },
});

// Get upcoming events/assignments with due dates
export const getUpcomingEvents = internalAction({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/users/self/upcoming_events`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const upcomingEvents = await response.json();
      return { success: true, data: upcomingEvents };
    } catch (error) {
      console.error("Error fetching Canvas upcoming events:", error);
      return { success: false, error: `Failed to fetch upcoming events: ${error}` };
    }
  },
});

// Get quizzes for a course
export const getQuizzes = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/quizzes`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const quizzes = await response.json();
      return { success: true, data: quizzes };
    } catch (error) {
      console.error("Error fetching Canvas quizzes:", error);
      return { success: false, error: `Failed to fetch quizzes: ${error}` };
    }
  },
});

// Get quiz details including questions
export const getQuizDetails = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
    quizId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/quizzes/${args.quizId}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const quizDetails = await response.json();
      
      // Get quiz questions
      const questionsUrl = `${baseUrl}api/v1/courses/${args.courseId}/quizzes/${args.quizId}/questions`;
      
      const questionsResponse = await fetch(questionsUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (questionsResponse.ok) {
        const questions = await questionsResponse.json();
        quizDetails.questions = questions;
      }
      
      return { success: true, data: quizDetails };
    } catch (error) {
      console.error("Error fetching Canvas quiz details:", error);
      return { success: false, error: `Failed to fetch quiz details: ${error}` };
    }
  },
});

// Get module items for a specific module
export const getModuleItems = internalAction({
  args: {
    userId: v.id("users"),
    courseId: v.string(),
    moduleId: v.string(),
  },
  handler: async (ctx, args): Promise<CanvasResponse<any[]>> => {
    try {
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      if (!user) {
        return { success: false, error: "User not found" };
      }
      
      if (!user.canvasAccessToken || !user.canvasUrl) {
        return { success: false, error: "Canvas credentials not found" };
      }
      
      const baseUrl = user.canvasUrl.endsWith('/') ? user.canvasUrl : `${user.canvasUrl}/`;
      const url = `${baseUrl}api/v1/courses/${args.courseId}/modules/${args.moduleId}/items`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user.canvasAccessToken}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Canvas API error: ${errorText}` };
      }
      
      const moduleItems = await response.json();
      return { success: true, data: moduleItems };
    } catch (error) {
      console.error("Error fetching Canvas module items:", error);
      return { success: false, error: `Failed to fetch module items: ${error}` };
    }
  },
});
</file>

<file path="convex/messages.ts">
import { v } from "convex/values";
import { mutation, query, internalMutation } from "./_generated/server";
import { Doc, Id } from "./_generated/dataModel";
import { internal, api } from "./_generated/api";

// Type definition for better type safety
type Message = {
  _id?: Id<"messages">;
  chatId: Id<"chats">;
  userId: Id<"users">;
  content: string;
  role: string;
  tokens?: number;
  functionCall?: string;
  createdAt: number; // Not optional
};

// Get all messages for a specific chat
export const getMessages = query({
  args: {
    chatId: v.id("chats"),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("messages")
      .withIndex("by_chatId", (q) => q.eq("chatId", args.chatId))
      .order("asc")
      .collect();
  },
});

// Save a new message to the database (internal function for OpenAI completion)
export const saveMessage = internalMutation({
  args: {
    chatId: v.id("chats"),
    userId: v.id("users"),
    content: v.string(),
    role: v.string(),
    tokens: v.optional(v.number()),
    functionCall: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    console.log("Saving message:", {
      chatId: args.chatId,
      role: args.role,
      contentLength: args.content.length,
      hasTokens: !!args.tokens,
      hasFunctionCall: !!args.functionCall
    });
    
    const messageData: Message = {
      chatId: args.chatId,
      userId: args.userId,
      content: args.content,
      role: args.role,
      tokens: args.tokens,
      functionCall: args.functionCall,
      createdAt: Date.now(),
    };
    
    return await ctx.db.insert("messages", messageData);
  },
});

// Send a message and get a response from the AI
export const sendMessage = mutation({
  args: {
    chatId: v.id("chats"),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    console.log("Starting sendMessage with args:", args);
    
    // Get the authenticated user
    const identity = await ctx.auth.getUserIdentity();
    console.log("User identity:", identity ? "authenticated" : "not authenticated");
    
    if (!identity) {
      throw new Error("Not authenticated - please sign in to send messages");
    }
    
    // Get user from database using identity
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => 
        q.eq("clerkId", identity.subject)
      )
      .unique();
    
    console.log("User lookup result:", user ? "found" : "not found");
    
    if (!user) {
      throw new Error("User not found - please refresh the page or sign in again");
    }
    
    // Save the user's message
    console.log("Inserting user message to chat:", args.chatId);
    const messageId = await ctx.db.insert("messages", {
      chatId: args.chatId,
      userId: user._id,
      content: args.content,
      role: "user",
      createdAt: Date.now(),
    });
    
    // Get all messages in the chat to provide context
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_chatId", (q) => q.eq("chatId", args.chatId))
      .order("asc")
      .collect();
    
    console.log("Found", messages.length, "messages in chat history");
    
    // Format messages for OpenAI
    const formattedMessages = messages.map(msg => ({
      role: msg.role,
      content: msg.content,
    }));
    
    try {
      console.log("Scheduling OpenAI response generation");
      // Call OpenAI to generate a response using our Canvas-enabled function
      await ctx.scheduler.runAfter(0, api.openai.generateChatCompletion, {
        messages: formattedMessages,
        chatId: args.chatId,
        userId: user._id,
      });
      
      console.log("Message sent successfully with ID:", messageId);
      return messageId;
    } catch (error) {
      console.error("Error sending message:", error);
      
      // Save error message
      await ctx.db.insert("messages", {
        chatId: args.chatId,
        userId: user._id,
        content: `Error: ${error}`,
        role: "assistant",
        createdAt: Date.now(),
      });
      
      return messageId;
    }
  },
});
</file>

<file path="convex/users.ts">
import { ConvexError, v } from "convex/values";
import { mutation, query, internalQuery } from "./_generated/server";
import { Id } from "./_generated/dataModel";

// Get the current authenticated user
export const getUser = query({
  args: {},
  handler: async (ctx) => {
    // Get the user's identity from Clerk
    const identity = await ctx.auth.getUserIdentity();
    
    // If not authenticated, return null
    if (!identity) {
      return null;
    }

    // Find the user in our database using their Clerk ID
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    return user;
  },
});

// Create a new user or update an existing one
export const createOrUpdateUser = mutation({
  args: {
    name: v.optional(v.string()),
    email: v.string(),
    imageUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Get the user's identity from Clerk
    const identity = await ctx.auth.getUserIdentity();
    
    // If not authenticated, throw an error
    if (!identity) {
      throw new ConvexError("Not authenticated");
    }

    // Check if the user already exists in our database
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    // If the user exists, return their ID
    if (existingUser) {
      // Optionally update user information if needed
      await ctx.db.patch(existingUser._id, {
        name: args.name,
        email: args.email,
        imageUrl: args.imageUrl,
        updatedAt: Date.now(),
      });
      return existingUser._id;
    }

    // If the user doesn't exist, create a new one
    const userId = await ctx.db.insert("users", {
      clerkId: identity.subject,
      name: args.name || "Anonymous",
      email: args.email,
      imageUrl: args.imageUrl,
      plan: "free", // Default to free plan
      credits: 10, // Start with some free credits
      usageTokens: 0,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    return userId;
  },
});

// Update Canvas settings for a user
export const updateCanvasSettings = mutation({
  args: {
    canvasEnabled: v.boolean(),
    canvasUrl: v.optional(v.string()),
    canvasAccessToken: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Get the user's identity from Clerk
    const identity = await ctx.auth.getUserIdentity();
    
    // If not authenticated, throw an error
    if (!identity) {
      throw new ConvexError("Not authenticated");
    }

    // Find the user in our database
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) {
      throw new ConvexError("User not found");
    }

    // Prepare update object
    const updateData: any = {
      canvasEnabled: args.canvasEnabled,
      updatedAt: Date.now(),
    };

    // Only include URL and token if enabled or if they're provided
    if (args.canvasEnabled) {
      if (!args.canvasUrl || !args.canvasAccessToken) {
        throw new ConvexError("Canvas URL and access token are required when Canvas is enabled");
      }
      updateData.canvasUrl = args.canvasUrl;
      updateData.canvasAccessToken = args.canvasAccessToken;
    }

    // Update the Canvas settings
    await ctx.db.patch(user._id, updateData);

    return user._id;
  },
});

// Get a user by ID (internal function)
export const getUserById = internalQuery({
  args: { userId: v.id("users") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.userId);
  },
});

// Get a user by their Clerk ID (internal function)
export const getUserByClerkId = internalQuery({
  args: {
    clerkId: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", args.clerkId))
      .unique();
  },
});
</file>

<file path="docs/architecture.md">
# Application Architecture

## Overview

Studi is a Next.js application designed to help students interact with their Canvas LMS data through a chat interface. The application uses a combination of client-side and server-side components, with Convex as the backend database and API layer.

## Tech Stack

- **Frontend**: Next.js 14 with React and TypeScript
- **Backend**: Convex for database and serverless functions
- **Authentication**: Clerk for user authentication
- **AI Integration**: OpenAI API for chat completions
- **Canvas Integration**: Canvas LMS API for educational data
- **Styling**: Tailwind CSS with shadcn/ui components

## Core Components

### Frontend Architecture

The frontend is organized into several key areas:

1. **Pages and Layouts**
   - App router-based structure with nested layouts
   - Main pages: Home, Chat, Dashboard, Settings

2. **Components**
   - UI components (buttons, inputs, etc.) from shadcn/ui
   - Custom components for specific features (ChatContainer, Message, etc.)
   - Layout components for page structure

3. **Hooks and Utilities**
   - Custom React hooks for state management
   - Utility functions for common operations
   - Logger for debugging and monitoring

### Backend Architecture (Convex)

The Convex backend handles:

1. **Database**
   - Users, chats, and messages storage
   - Relationships between entities

2. **API Endpoints**
   - Mutations for creating and updating data
   - Queries for retrieving data
   - Actions for external API calls (OpenAI, Canvas)

3. **Authentication**
   - Integration with Clerk for user authentication
   - User session management

### Data Flow

1. **User Authentication**
   - User signs in via Clerk
   - Authentication state is managed client-side
   - User data is stored in Convex

2. **Chat Interaction**
   - User sends a message via the UI
   - Message is stored in Convex
   - OpenAI API is called to generate a response
   - Response is stored and displayed to the user

3. **Canvas Integration**
   - User connects their Canvas account
   - Access token is securely stored
   - AI can request Canvas data via function calls
   - Data is fetched and presented to the user

## Key Files and Directories

```
studi/
├── src/
│   ├── app/                  # Next.js app router
│   │   ├── (auth)/           # Authentication pages
│   │   ├── (dashboard)/      # Dashboard pages
│   │   ├── api/              # API routes
│   │   ├── components/       # React components
│   │   │   ├── chat/         # Chat-related components
│   │   │   ├── ui/           # UI components
│   │   ├── lib/              # Utility libraries
│   │   └── types/            # TypeScript type definitions
│   ├── utils/                # Utility functions
│   │   └── logger.ts         # Logging utility
├── convex/                   # Convex backend
│   ├── _generated/           # Generated Convex files
│   ├── schema.ts             # Database schema
│   ├── users.ts              # User-related functions
│   ├── messages.ts           # Message-related functions
│   ├── chats.ts              # Chat-related functions
│   ├── canvas.ts             # Canvas integration
│   └── openai.ts             # OpenAI integration
├── public/                   # Static assets
└── docs/                     # Documentation
```

## Authentication Flow

1. User visits the application
2. If not authenticated, redirected to sign-in page
3. User signs in or creates an account via Clerk
4. On successful authentication:
   - Clerk provides a JWT token
   - Token is used to authenticate Convex requests
   - User data is created or retrieved from the database

## Chat System Architecture

The chat system consists of:

1. **ChatContainer Component**
   - Manages the UI for the chat interface
   - Handles message input and submission

2. **Message Component**
   - Renders individual messages
   - Supports different message types (user, assistant, system, function)

3. **Convex Backend**
   - `messages.ts`: Stores and retrieves messages
   - `openai.ts`: Handles AI message generation
   - `canvas.ts`: Processes Canvas-related function calls

4. **OpenAI Integration**
   - Processes user messages
   - Generates assistant responses
   - Handles function calling for Canvas data

## Canvas Integration

The Canvas integration allows:

1. **Authentication**
   - User connects their Canvas account via OAuth
   - Access token is securely stored in the database

2. **Data Access**
   - AI can request specific Canvas data via function calls
   - Available functions: get_courses, get_assignments, get_announcements, get_modules

3. **Data Presentation**
   - Canvas data is formatted and presented to the user
   - AI provides context and explanations for the data

## Logging System

The application uses a custom logger that:

1. Provides different log levels (debug, info, warn, error)
2. Supports context tagging for better organization
3. Formats logs with timestamps and additional metadata
4. Adjusts verbosity based on the environment

## Future Architecture Considerations

1. **Scalability**
   - Implement caching for frequently accessed data
   - Optimize database queries for performance

2. **Security**
   - Regular security audits
   - Implement rate limiting
   - Enhanced data encryption

3. **Features**
   - File upload and management
   - Real-time collaboration
   - Advanced Canvas integration features
</file>

<file path="docs/components.md">
# Studi Components Documentation

This document provides detailed information about the components used in the Studi frontend application.

## Animation Components

### `<FadeIn>`

A component that animates children by fading them in and sliding them up slightly.

**Props:**
- `children`: ReactNode (required) - The content to be animated
- `delay`: number (default: 0) - Delay before animation starts in seconds
- `duration`: number (default: 0.6) - Duration of animation in seconds
- `className`: string (default: '') - Additional CSS classes

**Usage:**
```tsx
<FadeIn delay={0.2} className="my-4">
  <p>This content will fade in</p>
</FadeIn>
```

### `<FloatingElement>`

A component that creates a floating animation for its children.

**Props:**
- `children`: ReactNode (required) - The content to be animated
- `amount`: number (default: 10) - The distance in pixels the element should float
- `duration`: number (default: 4) - Duration of one animation cycle in seconds
- `className`: string (default: '') - Additional CSS classes

**Usage:**
```tsx
<FloatingElement amount={15} duration={3}>
  <div className="icon">🚀</div>
</FloatingElement>
```

### `<GradientText>`

A component that applies a gradient effect to text.

**Props:**
- `children`: ReactNode (required) - The text content
- `className`: string (default: '') - Additional CSS classes

**Usage:**
```tsx
<GradientText className="text-2xl font-bold">
  Gradient Text
</GradientText>
```

### `<Reveal>`

A component that reveals its children with a directional animation.

**Props:**
- `children`: ReactNode (required) - The content to be revealed
- `direction`: 'left' | 'right' | 'up' | 'down' (default: 'up') - Direction of reveal
- `delay`: number (default: 0) - Delay before animation starts in seconds
- `className`: string (default: '') - Additional CSS classes

**Usage:**
```tsx
<Reveal direction="left" delay={0.3}>
  <div className="card">Content slides in from left</div>
</Reveal>
```

### `<Typewriter>`

A component that animates text character by character like a typewriter.

**Props:**
- `text`: string (required) - The text to be typed
- `delay`: number (default: 0) - Delay before animation starts in seconds
- `className`: string (default: '') - Additional CSS classes

**Usage:**
```tsx
<Typewriter text="Hello, world!" className="font-mono" />
```

## Layout Components

### `<Navigation>`

The main navigation header component with responsive mobile menu.

**Features:**
- Logo and branding
- Desktop and mobile navigation
- Scroll-aware background (transparent to solid)
- Sign up and login buttons

### `<Footer>`

The site footer component with links and information.

**Features:**
- Logo and company description
- Navigation links grouped by category
- Social media links
- Copyright and legal links

### Dashboard Layout

**File**: `frontend/src/app/(dashboard)/layout.tsx`

The main layout for authenticated users, featuring:

- A responsive sidebar with navigation and chat history
- Mobile menu toggle for small screens
- User profile section with Clerk integration
- Main content area with proper spacing and padding
- Animation effects using Framer Motion

```tsx
<motion.aside 
  className="fixed md:relative md:flex md:flex-col border-r border-black w-64 h-screen bg-white z-40"
  initial={{ x: -10, opacity: 0 }}
  animate={{ x: 0, opacity: 1 }}
  transition={{ duration: 0.3 }}
>
  {/* Sidebar Content */}
</motion.aside>
```

## Section Components

### `<Hero>`

The main hero section that appears at the top of the landing page.

**Features:**
- Main headline with typewriter effect
- Description text
- CTA buttons
- Visual elements and background patterns
- Social proof section

### `<Features>`

Showcases the main features of the product.

**Features:**
- Interactive feature selector
- Visual feature representation
- Custom icons for each feature

### `<Testimonials>`

Displays customer testimonials in a grid layout.

**Features:**
- Quote cards with attribution
- Grid layout optimized for different screen sizes

### `<Pricing>`

Displays pricing plans with feature comparison.

**Features:**
- Toggle between monthly and yearly billing
- Highlighted popular plan
- Feature lists with checkmarks
- CTA buttons for each plan

### `<CTA>`

Call to action section to prompt user sign-up.

**Features:**
- Prominent headline and description
- Primary and secondary CTA buttons
- Visual elements and background

## Dashboard Components

### Dashboard Page

**File**: `frontend/src/app/(dashboard)/dashboard/page.tsx`

The main dashboard page showing:

- Welcome section with user's profile
- Recent chats in a card grid
- Account information card
- Usage statistics
- Staggered animations for a pleasant loading experience

## Chat Components

### Chat Container

**File**: `frontend/src/app/components/chat/ChatContainer.tsx`

Container for the chat interface with:

- Header with chat title and actions
- Message list area
- Message input at the bottom
- Loading states and animations

### Message List

**File**: `frontend/src/app/components/chat/MessageList.tsx`

Displays a scrollable list of messages with:

- Auto-scrolling to the bottom for new messages
- Date separators between messages from different days
- Empty state when there are no messages
- Scroll-to-bottom button when not at the bottom

```tsx
<motion.div 
  variants={container}
  initial="hidden"
  animate="show"
  className="flex flex-col space-y-4 p-4"
>
  {/* Message items */}
</motion.div>
```

### Message Component

**File**: `frontend/src/app/components/chat/Message.tsx`

Individual message component with:

- Different styles for user vs. AI messages
- Avatar display
- Timestamp formatting
- Copy-to-clipboard functionality
- Like/reaction button
- Emoji rendering in message content

```tsx
<div className="flex items-start gap-3 p-5 rounded-lg hover:bg-gray-50 transition-colors">
  {/* Avatar */}
  <div className="message-content">
    {/* Message text */}
    {/* Actions (copy, like) */}
  </div>
  {/* Timestamp */}
</div>
```

### Message Input

**File**: `frontend/src/app/components/chat/MessageInput.tsx`

Input for typing new messages:

- Auto-resizing textarea
- Emoji picker/quick emojis
- Send button with animation
- Focus states and keyboard shortcuts
- Loading state during message sending

```tsx
<form className="border-t border-black p-4 bg-white">
  <div className="relative">
    {/* Textarea */}
    {/* Emoji picker */}
    {/* Send button */}
  </div>
</form>
```

### Chat List

**File**: `frontend/src/app/components/chat/ChatList.tsx`

List of chat conversations:

- New chat button
- List of existing chats
- Delete functionality
- Active state for current chat
- Empty state when no chats exist

## Authentication Components

### Auth Check

**File**: `frontend/src/app/components/auth/auth-check.tsx`

Handles authentication verification:

- Checks if user is signed in
- Creates user in database if they don't exist
- Redirects unauthenticated users

## Utility Components

### `<Logo>` and `<LogoText>`

Components for displaying the Studi logo.

**Props:**
- `size`: number (default: 32) - Size of the logo in pixels
- `className`: string (default: '') - Additional CSS classes

**Usage:**
```tsx
<Logo size={40} className="my-4" />
<LogoText className="text-lg" />
```

### Navigation

**File**: `frontend/src/app/components/navigation.tsx`

Main navigation component:

- Desktop and mobile navigation
- Logo and branding
- Navigation links
- Authentication buttons

## Common Design Patterns

### Button Styles

Buttons follow these common patterns:

1. **Primary Action**:
   ```tsx
   <button className="py-2 px-4 bg-black text-white font-medium rounded-lg hover:bg-gray-800 transition-colors">
     Button Text
   </button>
   ```

2. **Secondary Action**:
   ```tsx
   <button className="py-2 px-4 border border-black text-black font-medium rounded-lg hover:bg-gray-50 transition-colors">
     Button Text
   </button>
   ```

3. **Icon Button**:
   ```tsx
   <button className="p-2 text-gray-500 hover:text-black hover:bg-gray-100 rounded-full transition-colors">
     <IconComponent className="h-5 w-5" />
   </button>
   ```

### Card Patterns

Cards use these common patterns:

```tsx
<div className="bg-white shadow-sm border border-black rounded-lg p-6">
  <h2 className="text-xl font-semibold mb-4">Card Title</h2>
  <div className="card-content">
    {/* Content */}
  </div>
</div>
```

### Animation Patterns

Common animation patterns using Framer Motion:

1. **Staggered Children**:
   ```tsx
   const container = {
     hidden: { opacity: 0 },
     show: {
       opacity: 1,
       transition: {
         staggerChildren: 0.1
       }
     }
   };
   
   const item = {
     hidden: { opacity: 0, y: 20 },
     show: { opacity: 1, y: 0 }
   };
   ```

2. **Hover/Tap Effects**:
   ```tsx
   <motion.div
     whileHover={{ scale: 1.02 }}
     whileTap={{ scale: 0.98 }}
   >
     {/* Content */}
   </motion.div>
   ```

## Responsive Behavior

Components follow these responsive patterns:

- Mobile-first design with progressive enhancement
- Sidebar collapses to a mobile menu on smaller screens
- Grid layouts change from single column to multiple columns
- Font sizes and spacing adjust based on screen size
- Touch targets expand on mobile devices

## Accessibility Features

Components include these accessibility features:

- Semantic HTML structure
- Proper ARIA attributes
- Focus management
- Keyboard navigation
- Color contrast compliance
- Screen reader support

## Theme Integration

Components work with the application theme:

- White background with black borders
- Black primary buttons with white text
- Gray secondary and background colors
- Consistent spacing and typography
- Smooth transitions and animations

## Component Customization

Most components support customization through:

1. **Props**: For behavior and content
2. **className**: For styling customization with Tailwind
3. **Children**: For content customization

## Extending Components

To extend existing components:

1. Import the component
2. Wrap it with additional functionality
3. Pass props through to the base component

Example:
```tsx
import { FadeIn } from './animations';

export function EnhancedFadeIn({ children, ...props }) {
  // Add custom logic here
  
  return (
    <FadeIn {...props}>
      {children}
    </FadeIn>
  );
}
```

## Landing Page Components

### `<Hero>`

The main hero section of the landing page that introduces Studi as an AI-powered study assistant for Canvas LMS.

**Features:**
- Animated background with network-like pattern
- Headline with typewriter effect
- Clear value proposition and description
- Call-to-action buttons for early access
- Interactive preview of the AI chat functionality
- Responsive design for all device sizes

**Key Elements:**
- Canvas integration emphasis
- Modern, clean design with blue accent colors
- Animated elements for visual interest

### `<Features>`

Showcases the key features of Studi with visual illustrations.

**Features:**
- Grid layout of feature cards
- Icon illustrations for each feature
- Animated reveal on scroll
- Responsive design that adjusts columns based on screen size

**Key Features Highlighted:**
- Canvas LMS Integration
- AI-Powered Study Assistance
- Smart Assignment Help
- Course Material Organization
- Personalized Study Plans
- Collaborative Learning

### `<Testimonials>`

Displays user testimonials to build trust and showcase real-world benefits.

**Features:**
- Carousel of testimonial cards
- User avatars and names
- Star ratings
- Responsive design
- Subtle animations on hover

**Design Elements:**
- Clean card design with subtle shadows
- Emphasis on student experiences with Canvas integration
- Diverse representation of users

### `<CTA>` (Call to Action)

Encourages visitors to sign up for early access.

**Features:**
- Eye-catching background with gradient
- Clear headline and subheadline
- Email input field
- Submit button
- Privacy policy link
- Responsive design

**Design Elements:**
- Contrasting colors to draw attention
- Simple form with clear instructions
- Focus on early access to create urgency

### `<Footer>`

The footer section containing links, information, and copyright notice.

**Features:**
- Logo and company description
- Organized link sections (Product, Resources, Company, Legal)
- Social media links
- Copyright information
- Responsive grid layout

**Design Elements:**
- Clean organization of links
- Subtle separation between sections
- Consistent with overall design language

### `<Navigation>`

The navigation bar for the landing page.

**Features:**
- Logo and beta badge
- Desktop navigation links
- Authentication buttons (Sign in, Get Early Access)
- Mobile-responsive menu with hamburger icon
- Scroll effect that changes background on scroll
- User button for authenticated users

**Design Elements:**
- Clean, minimal design
- Consistent with overall color scheme
- Smooth animations for mobile menu
- Clear visual hierarchy

```
</file>

<file path="package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@clerk/nextjs": "^6.12.5",
    "@stripe/stripe-js": "^6.0.0",
    "@tailwindcss/typography": "^0.5.16",
    "convex": "^1.20.0",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.5.0",
    "lucide-react": "^0.479.0",
    "next": "15.2.2",
    "openai": "^4.87.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^10.1.0",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.2.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/(dashboard)/layout.tsx">
"use client";

import { UserButton, useUser } from "@clerk/nextjs";
import { AuthCheck } from "../components/auth/auth-check";
import Link from "next/link";
import { useState, useEffect } from "react";
import { usePathname, useRouter } from "next/navigation";
import { 
  Plus, 
  Settings, 
  MessageSquare, 
  Sparkles, 
  User,
  ChevronRight,
  Home
} from "lucide-react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { motion } from "framer-motion";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { isSignedIn, isLoaded, user } = useUser();
  const pathname = usePathname();
  const router = useRouter();
  const chats = useQuery(api.chats.getChats) || [];
  const createChat = useMutation(api.chats.createChat);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  
  useEffect(() => {
    // Close mobile menu when route changes
    setIsMobileMenuOpen(false);
  }, [pathname]);
  
  // Function to open Clerk user profile
  const openClerkProfile = () => {
    const userButtonElement = document.querySelector('.cl-userButtonTrigger') as HTMLElement;
    if (userButtonElement) {
      userButtonElement.click();
    }
  };
  
  const handleNewChat = async () => {
    try {
      const chatId = await createChat({ title: "New Chat" });
      if (chatId) {
        router.push(`/chat/${chatId}`);
      }
    } catch (error) {
      console.error("Failed to create new chat:", error);
    }
  };
  
  return (
    <>
      <AuthCheck />
      <div className="min-h-screen bg-white flex">
        {/* Mobile menu toggle */}
        <div className="fixed top-4 left-4 z-50 md:hidden">
          <button 
            onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
            className="p-2 rounded-md text-black border border-black"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              {isMobileMenuOpen ? (
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              ) : (
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              )}
            </svg>
          </button>
        </div>
        
        {/* Sidebar */}
        <motion.aside 
          className={`fixed md:relative md:flex md:flex-col border-r border-black w-64 h-screen bg-white z-40 ${
            isMobileMenuOpen ? 'flex flex-col' : 'hidden md:flex md:flex-col'
          }`}
          initial={{ x: -10, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <div className="flex items-center justify-between p-4 border-b border-black">
            <Link href="/dashboard" className="text-xl font-bold text-black">
              Studi
            </Link>
          </div>
          
          <div className="flex-1 overflow-y-auto">
            <div className="p-4 pb-1">
              <motion.button 
                onClick={handleNewChat}
                className="flex items-center gap-2 w-full p-2 rounded-md bg-black text-white hover:bg-gray-800 transition-colors"
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
              >
                <Plus size={18} />
                <span>New Chat</span>
              </motion.button>
            </div>
            
            {/* Navigation Links */}
            <nav className="px-4 pt-1">
              <Link 
                href="/dashboard" 
                className={`flex items-center gap-2 p-2 rounded-md transition-colors ${
                  pathname === '/dashboard' ? 'text-black font-medium bg-gray-100' : 'text-black hover:bg-gray-50'
                }`}
              >
                <Home size={18} />
                <span>Dashboard</span>
              </Link>
            </nav>
            
            {/* Chat List */}
            <div className="px-4 py-2">
              <div className="flex items-center justify-between mb-2">
                <h3 className="text-sm font-medium text-black">Recent Chats</h3>
                <ChevronRight size={16} className="text-black" />
              </div>
              <div className="space-y-1">
                {chats.map((chat) => (
                  <Link 
                    key={chat._id} 
                    href={`/chat/${chat._id}`}
                    className={`flex items-center gap-2 p-2 text-sm rounded-md transition-colors ${
                      pathname === `/chat/${chat._id}` ? 'bg-gray-100 text-black font-medium' : 'text-black hover:bg-gray-50'
                    }`}
                  >
                    <MessageSquare size={16} />
                    <span className="truncate">{chat.title || "New Chat"}</span>
                  </Link>
                ))}
                
                {chats.length === 0 && (
                  <p className="text-sm text-black py-2 px-2">No chats yet</p>
                )}
              </div>
            </div>
          </div>
          
          {/* User Section */}
          <div className="p-4 border-t border-black">
            <div className="flex items-center gap-3 mb-2">
              <UserButton afterSignOutUrl="/" />
              <div className="flex-1 min-w-0 cursor-pointer" onClick={openClerkProfile}>
                <p className="text-sm font-medium truncate text-black">{user?.fullName || user?.username}</p>
                <p className="text-xs text-black truncate hover:underline">{user?.primaryEmailAddress?.emailAddress}</p>
              </div>
            </div>
            <Link 
              href="/settings" 
              className={`flex items-center gap-2 p-2 text-sm rounded-md transition-colors ${
                pathname.startsWith('/settings') ? 'bg-gray-100 text-black font-medium' : 'text-black hover:bg-gray-50'
              }`}
            >
              <Settings size={16} />
              <span>Settings</span>
            </Link>
          </div>
        </motion.aside>
        
        {/* Main Content */}
        <div className="flex-1 md:ml-0 ml-0">
          <main className="h-screen overflow-y-auto p-6">
            {children}
          </main>
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/app/(dashboard)/settings/page.tsx">
"use client";

import { useState } from "react";
import { useUser } from "@clerk/nextjs";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { motion } from "framer-motion";
import { 
  User, 
  Shield, 
  Bell, 
  Moon, 
  Sun, 
  Palette, 
  LucideIcon,
  Loader2,
  Check,
  CreditCard,
  DollarSign,
  PlusCircle,
  XCircle,
  BookOpen,
  ToggleLeft,
  ToggleRight
} from "lucide-react";

type SettingSectionProps = {
  title: string;
  description: string;
  icon: LucideIcon;
  children: React.ReactNode;
};

function SettingSection({ title, description, icon: Icon, children }: SettingSectionProps) {
  return (
    <div className="border border-black rounded-lg p-6 bg-white">
      <div className="flex items-start gap-4 mb-6">
        <div className="w-10 h-10 rounded-full bg-black flex items-center justify-center flex-shrink-0">
          <Icon className="h-5 w-5 text-white" />
        </div>
        <div>
          <h2 className="text-xl font-bold text-black">{title}</h2>
          <p className="text-black font-medium">{description}</p>
        </div>
      </div>
      <div className="space-y-4">
        {children}
      </div>
    </div>
  );
}

export default function SettingsPage() {
  const { user } = useUser();
  const convexUser = useQuery(api.users.getUser);
  
  const [colorTheme, setColorTheme] = useState("light");
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [saving, setSaving] = useState(false);
  const [saved, setSaved] = useState(false);

  // Canvas settings state
  const [canvasEnabled, setCanvasEnabled] = useState(convexUser?.canvasEnabled || false);
  const [canvasUrl, setCanvasUrl] = useState(convexUser?.canvasUrl || "");
  const [canvasAccessToken, setCanvasAccessToken] = useState(convexUser?.canvasAccessToken || "");
  const [canvasSaving, setCanvasSaving] = useState(false);
  const [canvasSaved, setCanvasSaved] = useState(false);

  // Update Canvas settings mutation
  const updateCanvasSettings = useMutation(api.users.updateCanvasSettings);

  // Handle Canvas settings save
  const handleSaveCanvasSettings = async () => {
    setCanvasSaving(true);
    try {
      // If Canvas is enabled, we need both URL and access token
      if (canvasEnabled && (!canvasUrl || !canvasAccessToken)) {
        alert("Please enter both Canvas URL and access token");
        setCanvasSaving(false);
        return;
      }

      // Prepare the mutation arguments
      const args: any = { canvasEnabled };
      
      // Only include URL and token if Canvas is enabled
      if (canvasEnabled) {
        args.canvasUrl = canvasUrl;
        args.canvasAccessToken = canvasAccessToken;
      }

      await updateCanvasSettings(args);
      setCanvasSaved(true);
      setTimeout(() => setCanvasSaved(false), 2000);
    } catch (error) {
      console.error("Failed to save Canvas settings:", error);
      alert("Failed to save Canvas settings. Please try again.");
    } finally {
      setCanvasSaving(false);
    }
  };

  const handleSavePreferences = () => {
    // This would save the preferences to Convex
    setSaving(true);
    setTimeout(() => {
      setSaving(false);
      setSaved(true);
      setTimeout(() => setSaved(false), 2000);
    }, 1000);
  };

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  // Open Clerk profile
  const openClerkProfile = () => {
    const userButtonElement = document.querySelector('.cl-userButtonTrigger') as HTMLElement;
    if (userButtonElement) {
      userButtonElement.click();
    }
  };

  return (
    <motion.div 
      variants={container}
      initial="hidden"
      animate="show"
      className="max-w-4xl mx-auto space-y-6 pb-12"
    >
      <motion.div variants={item}>
        <h1 className="text-3xl font-bold text-black mb-2">Settings</h1>
        <p className="text-black font-medium">Manage your account and preferences.</p>
      </motion.div>

      <motion.div variants={item}>
        <SettingSection 
          title="Current Plan" 
          description="Manage your subscription plan and credits"
          icon={CreditCard}
        >
          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Current Plan</h3>
              <p className="text-sm text-black font-bold">{convexUser?.plan || "Free Plan"}</p>
            </div>
            <div className="flex items-center gap-2">
              <button 
                className="py-2 px-4 border border-black text-black rounded-md hover:bg-gray-50 transition-colors flex items-center gap-1"
              >
                <XCircle size={16} />
                Deactivate Plan
              </button>
              <button 
                className="py-2 px-4 bg-black text-white rounded-md hover:bg-gray-800 transition-colors flex items-center gap-1"
              >
                <PlusCircle size={16} />
                Upgrade
              </button>
            </div>
          </div>

          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Credits</h3>
              <p className="text-sm text-black">Current credit balance: <span className="font-bold">{convexUser?.credits || 0}</span></p>
            </div>
            <button 
              className="py-2 px-4 border border-black text-black rounded-md hover:bg-gray-50 transition-colors flex items-center gap-1"
            >
              <DollarSign size={16} />
              Add Credits
            </button>
          </div>

          <div className="flex items-center justify-between py-3">
            <div>
              <h3 className="font-bold text-black">Usage</h3>
              <p className="text-sm text-black">Tokens used: <span className="font-bold">{convexUser?.usageTokens || 0} / 5000</span></p>
            </div>
            <div className="w-32 h-2 bg-gray-200 rounded-full overflow-hidden">
              <div 
                className="h-full bg-black rounded-full" 
                style={{ width: `${Math.min(((convexUser?.usageTokens || 0) / 5000) * 100, 100)}%` }}
              ></div>
            </div>
          </div>
        </SettingSection>
      </motion.div>

      <motion.div variants={item}>
        <SettingSection 
          title="Account Settings" 
          description="Manage your account details and preferences"
          icon={User}
        >
          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Profile Information</h3>
              <p className="text-sm text-black">Update your personal information</p>
            </div>
            <button 
              onClick={openClerkProfile}
              className="py-2 px-4 bg-black text-white rounded-md hover:bg-gray-800 transition-colors"
            >
              Manage Profile
            </button>
          </div>

          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Email Address</h3>
              <p className="text-sm text-black">{user?.primaryEmailAddress?.emailAddress}</p>
            </div>
            <button 
              onClick={openClerkProfile}
              className="py-2 px-4 border border-black text-black rounded-md hover:bg-gray-50 transition-colors"
            >
              Change Email
            </button>
          </div>

          <div className="flex items-center justify-between py-3">
            <div>
              <h3 className="font-bold text-black">Password</h3>
              <p className="text-sm text-black">Update your password</p>
            </div>
            <button 
              onClick={openClerkProfile}
              className="py-2 px-4 border border-black text-black rounded-md hover:bg-gray-50 transition-colors"
            >
              Change Password
            </button>
          </div>
        </SettingSection>
      </motion.div>

      <motion.div variants={item}>
        <SettingSection 
          title="Canvas Integration" 
          description="Connect to your Canvas LMS account"
          icon={BookOpen}
        >
          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Enable Canvas Integration</h3>
              <p className="text-sm text-black">Connect Studi AI to your Canvas LMS account</p>
            </div>
            <button 
              onClick={() => setCanvasEnabled(!canvasEnabled)}
              className="p-2 rounded-md flex items-center gap-2"
            >
              {canvasEnabled ? (
                <ToggleRight size={24} className="text-black" />
              ) : (
                <ToggleLeft size={24} className="text-black" />
              )}
            </button>
          </div>

          {canvasEnabled && (
            <>
              <div className="py-3 border-b border-gray-200">
                <h3 className="font-bold text-black mb-2">Canvas URL</h3>
                <p className="text-sm text-black mb-2">Enter your Canvas instance URL (e.g., https://university.instructure.com)</p>
                <input
                  type="text"
                  value={canvasUrl}
                  onChange={(e) => setCanvasUrl(e.target.value)}
                  placeholder="https://university.instructure.com"
                  className="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-black text-black"
                />
              </div>

              <div className="py-3 border-b border-gray-200">
                <h3 className="font-bold text-black mb-2">Canvas Access Token</h3>
                <p className="text-sm text-black mb-2">Enter your Canvas API access token</p>
                <input
                  type="password"
                  value={canvasAccessToken}
                  onChange={(e) => setCanvasAccessToken(e.target.value)}
                  placeholder="Canvas API access token"
                  className="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-black text-black"
                />
                <p className="text-xs text-gray-500 mt-1">
                  You can generate an access token in your Canvas account settings.
                </p>
              </div>
            </>
          )}

          <div className="flex justify-end mt-4">
            <button
              onClick={handleSaveCanvasSettings}
              disabled={canvasSaving}
              className="py-2 px-4 bg-black text-white rounded-md hover:bg-gray-800 transition-colors flex items-center gap-2"
            >
              {canvasSaving ? (
                <>
                  <Loader2 size={16} className="animate-spin" />
                  Saving...
                </>
              ) : canvasSaved ? (
                <>
                  <Check size={16} />
                  Saved!
                </>
              ) : (
                "Save Canvas Settings"
              )}
            </button>
          </div>
        </SettingSection>
      </motion.div>

      <motion.div variants={item}>
        <SettingSection 
          title="Appearance" 
          description="Customize how Studi AI looks"
          icon={Palette}
        >
          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Theme</h3>
              <p className="text-sm text-black">Choose between light and dark mode</p>
            </div>
            <div className="flex items-center gap-3">
              <button 
                onClick={() => setColorTheme("light")}
                className={`p-2 rounded-md flex items-center gap-2 ${
                  colorTheme === "light" 
                    ? "bg-black text-white" 
                    : "border border-black text-black"
                }`}
              >
                <Sun size={16} />
                Light
              </button>
              <button 
                onClick={() => setColorTheme("dark")}
                className={`p-2 rounded-md flex items-center gap-2 ${
                  colorTheme === "dark" 
                    ? "bg-black text-white" 
                    : "border border-black text-black"
                }`}
              >
                <Moon size={16} />
                Dark
              </button>
            </div>
          </div>
        </SettingSection>
      </motion.div>

      <motion.div variants={item}>
        <SettingSection 
          title="Notifications" 
          description="Manage your notification preferences"
          icon={Bell}
        >
          <div className="flex items-center justify-between py-3">
            <div>
              <h3 className="font-bold text-black">Email Notifications</h3>
              <p className="text-sm text-black">Receive updates via email</p>
            </div>
            <label className="relative inline-flex items-center cursor-pointer">
              <input 
                type="checkbox" 
                checked={notificationsEnabled} 
                onChange={() => setNotificationsEnabled(!notificationsEnabled)} 
                className="sr-only peer"
              />
              <div className="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-black"></div>
            </label>
          </div>
        </SettingSection>
      </motion.div>

      <motion.div variants={item}>
        <SettingSection 
          title="Privacy & Security" 
          description="Manage your security settings and data"
          icon={Shield}
        >
          <div className="flex items-center justify-between py-3 border-b border-gray-200">
            <div>
              <h3 className="font-bold text-black">Data Storage</h3>
              <p className="text-sm text-black">Your chats are securely stored</p>
            </div>
            <button 
              className="py-2 px-4 border border-black text-black rounded-md hover:bg-gray-50 transition-colors"
            >
              Manage Data
            </button>
          </div>

          <div className="flex items-center justify-between py-3">
            <div>
              <h3 className="font-bold text-black">Delete Account</h3>
              <p className="text-sm text-black">Permanently delete your account and all data</p>
            </div>
            <button 
              onClick={openClerkProfile}
              className="py-2 px-4 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
            >
              Delete Account
            </button>
          </div>
        </SettingSection>
      </motion.div>

      <motion.div variants={item} className="flex justify-end">
        <button
          onClick={handleSavePreferences}
          disabled={saving || saved}
          className="py-2 px-6 bg-black text-white rounded-md hover:bg-gray-800 transition-colors flex items-center gap-2"
        >
          {saving ? (
            <>
              <Loader2 size={18} className="animate-spin" />
              Saving...
            </>
          ) : saved ? (
            <>
              <Check size={18} />
              Saved!
            </>
          ) : (
            'Save Preferences'
          )}
        </button>
      </motion.div>
    </motion.div>
  );
}
</file>

<file path="src/app/components/auth/auth-check.tsx">
"use client";

import { useUser } from "@clerk/nextjs";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { useEffect } from "react";
import { useConvex } from "convex/react";
import { logger } from "../../../utils/logger";

export const AuthCheck = () => {
  const { isSignedIn, user } = useUser();
  const convex = useConvex();
  const convexUser = useQuery(api.users.getUser);

  // When a user signs in with Clerk, create or update the user in Convex
  useEffect(() => {
    if (isSignedIn && user && !convexUser) {
      // Create or update the user in Convex
      const createUser = async () => {
        logger.info("Creating/updating user in Convex", { userId: user.id }, "auth");
        try {
          await convex.mutation(api.users.createOrUpdateUser, {
            email: user.emailAddresses[0]?.emailAddress || "",
            name: user.fullName || "",
            imageUrl: user.imageUrl || "",
          });
          logger.info("User created/updated successfully", null, "auth");
        } catch (error) {
          logger.error("Failed to create/update user", { error }, "auth");
        }
      };
      createUser();
    }
  }, [isSignedIn, user, convexUser, convex]);

  return null; // This component doesn't render anything
};
</file>

<file path="src/app/components/chat/ChatContainer.tsx">
"use client";

import { useEffect, useRef, useCallback, useState } from "react";
import { Message as MessageType } from "@/types/chat";
import { 
  ArrowUp, 
  Paperclip, 
  Plus, 
  ArrowLeft, 
  Loader2, 
  Edit,
  Trash,
  Check,
  X
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { useRouter } from "next/navigation";
import { Message } from "./Message";
import { logger } from "../../../utils/logger";
import { Id } from "../../../../convex/_generated/dataModel";

type ChatContainerProps = {
  messages: MessageType[];
  isLoading: boolean;
  onSendMessage: (content: string) => void;
  title?: string;
  chatId?: string;
  onUpdateTitle?: (newTitle: string) => void;
  onDeleteChat?: () => void;
};

export function ChatContainer({ 
  messages, 
  isLoading, 
  onSendMessage,
  title,
  chatId,
  onUpdateTitle,
  onDeleteChat
}: ChatContainerProps) {
  const [message, setMessage] = useState("");
  const [isEditing, setIsEditing] = useState(false);
  const [editedTitle, setEditedTitle] = useState(title || "New Chat");
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const titleInputRef = useRef<HTMLInputElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const router = useRouter();
  
  // Update edited title when title prop changes
  useEffect(() => {
    if (title) {
      setEditedTitle(title);
    }
  }, [title]);
  
  // Custom hooks for auto-resizing textarea
  const adjustTextareaHeight = useCallback(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    // Reset height to calculate the right scrollHeight
    textarea.style.height = "60px";
    
    // Calculate new height (with max height)
    const newHeight = Math.min(textarea.scrollHeight, 200);
    textarea.style.height = `${newHeight}px`;
  }, []);
  
  // Handle sending message
  const handleSendMessage = () => {
    if (!message.trim() || isLoading) return;
    
    logger.info('Sending message', { chatId, contentLength: message.length }, 'chat');
    onSendMessage(message.trim());
    setMessage("");
    
    // Reset textarea height
    if (textareaRef.current) {
      textareaRef.current.style.height = "60px";
    }
  };
  
  // Handle key press (Enter to send, Shift+Enter for new line)
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // Start editing title
  const startEditingTitle = () => {
    setIsEditing(true);
    setTimeout(() => {
      titleInputRef.current?.focus();
      titleInputRef.current?.select();
    }, 10);
  };

  // Save edited title
  const saveEditedTitle = () => {
    if (onUpdateTitle && editedTitle.trim()) {
      logger.info('Updating chat title', { chatId, newTitle: editedTitle }, 'chat');
      onUpdateTitle(editedTitle.trim());
    }
    setIsEditing(false);
  };

  // Cancel title editing
  const cancelEditingTitle = () => {
    setEditedTitle(title || "New Chat");
    setIsEditing(false);
  };

  // Handle title input key press
  const handleTitleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      saveEditedTitle();
    } else if (e.key === "Escape") {
      cancelEditingTitle();
    }
  };

  // Handle chat deletion
  const handleDeleteChat = () => {
    if (confirm("Are you sure you want to delete this chat? This action cannot be undone.")) {
      logger.info('Deleting chat', { chatId }, 'chat');
      onDeleteChat?.();
    }
  };

  // Scroll to bottom when messages change
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
    }
    
    // Adjust textarea height on mount
    if (textareaRef.current) {
      textareaRef.current.style.height = "60px";
    }
  }, [messages]);

  // Format messages for our components
  const formattedMessages = messages.map(msg => ({
    id: msg._id,
    content: msg.content,
    role: msg.role,
    timestamp: new Date(msg._creationTime),
    originalChatId: msg.chatId, // Keep the original chatId for reference
    functionCall: msg.functionCall ? JSON.parse(msg.functionCall) : undefined
  }));

  return (
    <div className="flex flex-col h-[calc(100vh-64px)] bg-white">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-black">
        <div className="flex items-center">
          <motion.button 
            onClick={() => router.push("/dashboard")}
            className="p-2 rounded-full hover:bg-gray-100 transition-colors"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            <ArrowLeft className="h-5 w-5 text-black" />
          </motion.button>
          
          {isEditing ? (
            <div className="ml-2 flex items-center">
              <input
                ref={titleInputRef}
                type="text"
                value={editedTitle}
                onChange={(e) => setEditedTitle(e.target.value)}
                onKeyDown={handleTitleKeyDown}
                className="text-xl font-semibold text-black bg-white border-b border-black px-1 py-0.5 focus:outline-none"
                autoFocus
              />
              <motion.button 
                onClick={saveEditedTitle}
                className="p-1 ml-1 rounded-full hover:bg-gray-100"
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
              >
                <Check className="h-4 w-4 text-green-600" />
              </motion.button>
              <motion.button 
                onClick={cancelEditingTitle}
                className="p-1 rounded-full hover:bg-gray-100"
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
              >
                <X className="h-4 w-4 text-red-600" />
              </motion.button>
            </div>
          ) : (
            <h1 className="ml-2 text-xl font-semibold text-black">{title || "New Chat"}</h1>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          {!isEditing && onUpdateTitle && (
            <motion.button
              onClick={startEditingTitle}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="p-2 rounded-full hover:bg-gray-100 text-black"
              title="Edit chat title"
            >
              <Edit className="h-4 w-4" />
            </motion.button>
          )}
          
          {onDeleteChat && (
            <motion.button
              onClick={handleDeleteChat}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="p-2 rounded-full hover:bg-gray-100 text-black"
              title="Delete chat"
            >
              <Trash className="h-4 w-4" />
            </motion.button>
          )}
        </div>
      </div>
      
      {/* Messages area */}
      <div className="flex-1 overflow-y-auto px-4 pt-6 pb-4">
        <div className="max-w-4xl mx-auto">
          {formattedMessages.length === 0 ? (
            <div className="flex flex-col items-center w-full max-w-4xl mx-auto space-y-8">
              <h1 className="text-4xl font-bold text-black">
                What would you like to know?
              </h1>
            </div>
          ) : (
            <div className="space-y-4">
              {formattedMessages.map((msg) => (
                <Message
                  key={msg.id}
                  message={{
                    _id: msg.id,
                    content: msg.content,
                    role: msg.role,
                    _creationTime: msg.timestamp.getTime(),
                    chatId: msg.originalChatId,
                    functionCall: msg.functionCall ? JSON.stringify(msg.functionCall) : undefined
                  }}
                />
              ))}
            </div>
          )}
          
          {isLoading && (
            <div className="flex justify-center ml-8 my-4">
              <div className="animate-pulse bg-white border border-black rounded-lg p-4 max-w-md shadow-sm">
                <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
                <div className="h-4 bg-gray-200 rounded w-1/2"></div>
              </div>
            </div>
          )}
          
          <div ref={messagesEndRef} />
        </div>
      </div>
      
      {/* Input area */}
      <div className="border-t border-black p-4 bg-white">
        <div className="max-w-4xl mx-auto relative">
          <textarea
            ref={textareaRef}
            value={message}
            onChange={(e) => {
              setMessage(e.target.value);
              adjustTextareaHeight();
            }}
            onKeyDown={handleKeyDown}
            placeholder="Type your message..."
            className="w-full border border-black rounded-lg p-3 pr-14 resize-none focus:outline-none focus:ring-2 focus:ring-black focus:border-transparent text-black"
            style={{ height: "60px", maxHeight: "200px" }}
            disabled={isLoading}
          />
          <button
            type="button"
            onClick={handleSendMessage}
            disabled={!message.trim() || isLoading}
            className="absolute right-3 bottom-3 p-2 bg-black text-white rounded-full hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {isLoading ? (
              <Loader2 className="h-5 w-5 animate-spin" />
            ) : (
              <ArrowUp className="h-5 w-5" />
            )}
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/components/chat/MessageList.tsx">
"use client";

import { useMemo } from "react";
import { Message as MessageType } from "@/types/chat";
import { Message } from "./Message";
import { AnimatePresence, motion } from "framer-motion";
import { Calendar } from "lucide-react";

type MessageListProps = {
  messages: MessageType[];
};

export function MessageList({ messages }: MessageListProps) {
  // Group messages by date
  const groupedMessages = useMemo(() => {
    const groups: { date: string; messages: MessageType[] }[] = [];
    
    messages.forEach((message) => {
      const date = new Date(message._creationTime).toLocaleDateString(undefined, {
        weekday: "long",
        month: "long",
        day: "numeric"
      });
      
      const lastGroup = groups[groups.length - 1];
      
      if (lastGroup && lastGroup.date === date) {
        lastGroup.messages.push(message);
      } else {
        groups.push({ date, messages: [message] });
      }
    });
    
    return groups;
  }, [messages]);

  if (messages.length === 0) {
    return null;
  }

  return (
    <div className="space-y-6 relative">
      <AnimatePresence initial={false}>
        {groupedMessages.map((group, groupIndex) => (
          <motion.div 
            key={group.date}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.4, ease: "easeOut" }}
            className="space-y-6"
          >
            <div className="sticky top-0 z-10 py-2 flex justify-center">
              <motion.div 
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.1, duration: 0.3 }}
                className="bg-white px-4 py-1.5 rounded-full shadow-sm flex items-center gap-1.5"
              >
                <Calendar size={14} className="text-black" />
                <span className="text-xs font-medium text-black">{group.date}</span>
              </motion.div>
            </div>
            
            <div className="space-y-4 px-4">
              {group.messages.map((message, index) => (
                <motion.div
                  key={message._id}
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ 
                    duration: 0.3, 
                    delay: Math.min(0.05 * index, 0.3),
                    ease: "easeOut"
                  }}
                >
                  <Message message={message} />
                </motion.div>
              ))}
            </div>
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="src/types/chat.ts">
/**
 * Types related to chat functionality
 */

import { Id } from "../../convex/_generated/dataModel";

/**
 * Represents a chat message in the system
 */
export interface Message {
  _id: Id<"messages">;
  _creationTime: number;
  chatId: Id<"chats">;
  content: string;
  role: "user" | "assistant" | "system" | "function";
  isDeleted?: boolean;
  isLoading?: boolean;
  isError?: boolean;
  functionCall?: string; // JSON string of function call data
}

/**
 * Represents a chat thread
 */
export interface Chat {
  _id: Id<"chats">;
  _creationTime: number;
  title: string;
  userId: string;
  isDeleted?: boolean;
}
</file>

<file path="convex/openai.ts">
import { v } from "convex/values";
import { action } from "./_generated/server";
import { OpenAI } from "openai";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// Define types for better type safety
type User = {
  _id: Id<"users">;
  canvasEnabled?: boolean;
  canvasAccessToken?: string;
  canvasUrl?: string;
  [key: string]: any;
};

type FunctionCallResult = {
  name: string;
  arguments: any;
  result: any;
};

type GenerateChatCompletionResponse = {
  message: string;
  usage?: any;
  functionCall?: FunctionCallResult;
};

// Define Canvas function schemas for OpenAI
const canvasFunctions = [
  {
    name: "get_courses",
    description: "Get the user's courses from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  {
    name: "get_assignments",
    description: "Get assignments for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_announcements",
    description: "Get announcements for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_modules",
    description: "Get modules for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_files",
    description: "Get files for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_file_download_url",
    description: "Get download URL for a specific file from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        file_id: {
          type: "string",
          description: "The Canvas file ID"
        }
      },
      required: ["file_id"]
    }
  },
  {
    name: "get_course_grades",
    description: "Get grades for assignments in a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_enrollment_grades",
    description: "Get overall grades for all enrolled courses from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  {
    name: "get_discussions",
    description: "Get discussion topics for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_discussion_details",
    description: "Get details for a specific discussion topic including entries and replies",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        },
        discussion_id: {
          type: "string",
          description: "The Canvas discussion topic ID"
        }
      },
      required: ["course_id", "discussion_id"]
    }
  },
  {
    name: "get_user_profile",
    description: "Get the user's profile information from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  {
    name: "get_user_enrollments",
    description: "Get the user's enrollments (courses with roles) from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  {
    name: "get_calendar_events",
    description: "Get calendar events from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        start_date: {
          type: "string",
          description: "The start date for calendar events (YYYY-MM-DD)"
        },
        end_date: {
          type: "string",
          description: "The end date for calendar events (YYYY-MM-DD)"
        }
      },
      required: []
    }
  },
  {
    name: "get_upcoming_events",
    description: "Get upcoming events/assignments with due dates from Canvas LMS",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  },
  {
    name: "get_quizzes",
    description: "Get quizzes for a specific course from Canvas LMS",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        }
      },
      required: ["course_id"]
    }
  },
  {
    name: "get_quiz_details",
    description: "Get details for a specific quiz including questions",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        },
        quiz_id: {
          type: "string",
          description: "The Canvas quiz ID"
        }
      },
      required: ["course_id", "quiz_id"]
    }
  },
  {
    name: "get_module_items",
    description: "Get items for a specific module in a course",
    parameters: {
      type: "object",
      properties: {
        course_id: {
          type: "string",
          description: "The Canvas course ID"
        },
        module_id: {
          type: "string",
          description: "The Canvas module ID"
        }
      },
      required: ["course_id", "module_id"]
    }
  }
];

// Initialize OpenAI client
async function getOpenAIClient() {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error("OPENAI_API_KEY is not defined in environment variables");
  }
  
  return new OpenAI({
    apiKey,
  });
}

// Generate a chat completion using OpenAI
export const generateChatCompletion = action({
  args: {
    messages: v.array(
      v.object({
        role: v.string(),
        content: v.string(),
      })
    ),
    chatId: v.id("chats"),
    userId: v.id("users"),
  },
  handler: async (ctx, args): Promise<GenerateChatCompletionResponse> => {
    console.log(`[OpenAI] Starting chat completion for chat ${args.chatId}`);
    
    // Get OpenAI client
    const openai = await getOpenAIClient();
    
    try {
      // Get user to check if Canvas is enabled
      const user: User | null = await ctx.runQuery(internal.users.getUserById, { userId: args.userId });
      
      console.log(`[OpenAI] User ${args.userId} Canvas enabled: ${user?.canvasEnabled}`);
      
      // Prepare system message
      const systemMessage = {
        role: "system",
        content: "You are a knowledgeable AI assistant called studi specializing in educational content. Format your responses in a blog-style with proper markdown formatting including headings, bullet points, and code blocks where appropriate. Be informative yet conversational, and organize complex information with clear structure. " +
                 (user?.canvasEnabled ? "You can access the user's Canvas LMS data to provide educational assistance and structure this information in a readable, well-formatted way." : "")
      };
      
      // Combine system message with user messages and cast to any to avoid type issues
      const formattedMessages: any = [
        systemMessage,
        ...args.messages.map(msg => ({
          role: msg.role,
          content: msg.content
        }))
      ];
      
      // Only include Canvas functions if Canvas integration is enabled
      const functions = user?.canvasEnabled ? canvasFunctions : [];
      
      console.log(`[OpenAI] Sending request with ${formattedMessages.length} messages and ${functions.length} available functions`);
      
      // Call OpenAI API with any type to bypass TypeScript errors
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: formattedMessages,
        functions: functions.length > 0 ? functions : undefined,
        function_call: functions.length > 0 ? "auto" : undefined,
        temperature: 0.7,
        max_tokens: 1000,
      } as any);
      
      const responseMessage = response.choices[0]?.message;
      
      // Check if the model wants to call a function
      if (responseMessage.function_call) {
        const functionName = responseMessage.function_call.name;
        const functionArgs = JSON.parse(responseMessage.function_call.arguments);
        
        console.log(`[OpenAI] Function call detected: ${functionName}`, { args: functionArgs });
        
        // Execute the appropriate Canvas function
        let functionResult;
        
        try {
          switch (functionName) {
            case "get_courses":
              console.log(`[OpenAI] Executing get_courses for user ${args.userId}`);
              functionResult = await ctx.runAction(internal.canvas.getCourses, { 
                userId: args.userId 
              });
              break;
            case "get_assignments":
              console.log(`[OpenAI] Executing get_assignments for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getAssignments, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_announcements":
              console.log(`[OpenAI] Executing get_announcements for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getAnnouncements, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_modules":
              console.log(`[OpenAI] Executing get_modules for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getModules, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_files":
              console.log(`[OpenAI] Executing get_files for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getFiles, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_file_download_url":
              console.log(`[OpenAI] Executing get_file_download_url for file ${functionArgs.file_id}`);
              functionResult = await ctx.runAction(internal.canvas.getFileDownloadUrl, { 
                userId: args.userId,
                fileId: functionArgs.file_id
              });
              break;
            case "get_course_grades":
              console.log(`[OpenAI] Executing get_course_grades for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getCourseGrades, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_enrollment_grades":
              console.log(`[OpenAI] Executing get_enrollment_grades for user ${args.userId}`);
              functionResult = await ctx.runAction(internal.canvas.getEnrollmentGrades, { 
                userId: args.userId
              });
              break;
            case "get_discussions":
              console.log(`[OpenAI] Executing get_discussions for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getDiscussions, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_discussion_details":
              console.log(`[OpenAI] Executing get_discussion_details for discussion ${functionArgs.discussion_id}`);
              functionResult = await ctx.runAction(internal.canvas.getDiscussionDetails, { 
                userId: args.userId,
                courseId: functionArgs.course_id,
                discussionId: functionArgs.discussion_id
              });
              break;
            case "get_user_profile":
              console.log(`[OpenAI] Executing get_user_profile for user ${args.userId}`);
              functionResult = await ctx.runAction(internal.canvas.getUserProfile, { 
                userId: args.userId
              });
              break;
            case "get_user_enrollments":
              console.log(`[OpenAI] Executing get_user_enrollments for user ${args.userId}`);
              functionResult = await ctx.runAction(internal.canvas.getUserEnrollments, { 
                userId: args.userId
              });
              break;
            case "get_calendar_events":
              console.log(`[OpenAI] Executing get_calendar_events`);
              functionResult = await ctx.runAction(internal.canvas.getCalendarEvents, { 
                userId: args.userId,
                startDate: functionArgs.start_date,
                endDate: functionArgs.end_date
              });
              break;
            case "get_upcoming_events":
              console.log(`[OpenAI] Executing get_upcoming_events for user ${args.userId}`);
              functionResult = await ctx.runAction(internal.canvas.getUpcomingEvents, { 
                userId: args.userId
              });
              break;
            case "get_quizzes":
              console.log(`[OpenAI] Executing get_quizzes for course ${functionArgs.course_id}`);
              functionResult = await ctx.runAction(internal.canvas.getQuizzes, { 
                userId: args.userId,
                courseId: functionArgs.course_id
              });
              break;
            case "get_quiz_details":
              console.log(`[OpenAI] Executing get_quiz_details for quiz ${functionArgs.quiz_id}`);
              functionResult = await ctx.runAction(internal.canvas.getQuizDetails, { 
                userId: args.userId,
                courseId: functionArgs.course_id,
                quizId: functionArgs.quiz_id
              });
              break;
            case "get_module_items":
              console.log(`[OpenAI] Executing get_module_items for module ${functionArgs.module_id}`);
              functionResult = await ctx.runAction(internal.canvas.getModuleItems, { 
                userId: args.userId,
                courseId: functionArgs.course_id,
                moduleId: functionArgs.module_id
              });
              break;
            default:
              console.error(`[OpenAI] Unknown function: ${functionName}`);
              functionResult = { error: "Function not implemented" };
          }
          
          console.log(`[OpenAI] Function ${functionName} executed successfully`, { 
            success: functionResult.success,
            hasData: functionResult.data ? true : false,
            hasError: functionResult.error ? true : false
          });
        } catch (error) {
          console.error(`[OpenAI] Error executing function ${functionName}:`, error);
          functionResult = { error: `Error executing function: ${error}` };
        }
        
        // Add the function result to the messages for the second API call
        const secondCallMessages: any = [
          ...formattedMessages,
          {
            role: "assistant",
            content: null,
            function_call: {
              name: functionName,
              arguments: responseMessage.function_call.arguments
            }
          },
          {
            role: "function",
            name: functionName,
            content: JSON.stringify(functionResult)
          }
        ];
        
        console.log(`[OpenAI] Sending second request with function results for ${functionName}`);
        
        // Call the model again with the function result
        const secondResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: secondCallMessages,
          temperature: 0.7,
          max_tokens: 1000,
        } as any);
        
        const finalMessage: string = secondResponse.choices[0]?.message?.content || "Sorry, I couldn't generate a response.";
        
        console.log(`[OpenAI] Received final response with ${finalMessage.length} characters`);
        
        // Save the assistant's message to the database with function call data
        await ctx.runMutation(internal.messages.saveMessage, {
          chatId: args.chatId,
          userId: args.userId,
          content: finalMessage,
          role: "assistant",
          tokens: secondResponse.usage?.total_tokens || 0,
          functionCall: JSON.stringify({
            name: functionName,
            arguments: functionArgs,
            result: functionResult
          })
        });
        
        console.log(`[OpenAI] Saved assistant message with function call data`);
        
        return { 
          message: finalMessage,
          usage: secondResponse.usage,
          functionCall: {
            name: functionName,
            arguments: functionArgs,
            result: functionResult
          }
        };
      }
      
      // Get the generated response for non-function calls
      const assistantMessage: string = responseMessage.content || "Sorry, I couldn't generate a response.";
      
      console.log(`[OpenAI] Received standard response with ${assistantMessage.length} characters`);
      
      // Save the assistant's message to the database
      await ctx.runMutation(internal.messages.saveMessage, {
        chatId: args.chatId,
        userId: args.userId,
        content: assistantMessage,
        role: "assistant",
        tokens: response.usage?.total_tokens || 0,
      });
      
      console.log(`[OpenAI] Saved standard assistant message`);
      
      return { 
        message: assistantMessage,
        usage: response.usage
      };
    } catch (error) {
      console.error("[OpenAI] Error generating chat completion:", error);
      
      // Save error message to the database
      await ctx.runMutation(internal.messages.saveMessage, {
        chatId: args.chatId,
        userId: args.userId,
        content: `I'm sorry, but I encountered an error while processing your request. Please try again later.`,
        role: "assistant",
      });
      
      return { 
        message: "Error generating response. Please try again later."
      };
    }
  },
});
</file>

<file path="convex/schema.ts">
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Users table to store user data and subscription information
  users: defineTable({
    // Canvas integration
    canvasAccessToken: v.optional(v.string()),
    canvasEnabled: v.optional(v.boolean()),
    canvasUrl: v.optional(v.string()),
    
    // Auth data
    clerkId: v.string(),
    name: v.optional(v.string()),
    email: v.string(),
    imageUrl: v.optional(v.string()),
    
    // Subscription data
    stripeCustomerId: v.optional(v.string()),
    stripeSubscriptionId: v.optional(v.string()),
    stripePriceId: v.optional(v.string()),
    stripeCurrentPeriodEnd: v.optional(v.number()),
    
    // Plan details
    plan: v.optional(v.string()), // "free", "basic", "premium"
    
    // Usage tracking
    credits: v.optional(v.number()),
    usageTokens: v.optional(v.number()),
    
    // Metadata
    createdAt: v.number(),
    updatedAt: v.number(),
  })
  .index("by_clerkId", ["clerkId"])
  .index("by_email", ["email"])
  .index("by_subscription", ["stripeSubscriptionId"]),

  // Chats table
  chats: defineTable({
    userId: v.id("users"),
    title: v.string(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
  .index("by_userId", ["userId"]),

  

  // Messages table
  messages: defineTable({
    chatId: v.id("chats"),
    content: v.string(),
    createdAt: v.float64(),
    role: v.string(),
    tokens: v.optional(v.float64()),
    isError: v.optional(v.boolean()),  // Add this field
    isLoading: v.optional(v.boolean()),
    userId: v.optional(v.id("users")),
    functionCall: v.optional(v.string()),
    functionData: v.optional(v.object({
      name: v.string(),
      arguments: v.string(),
      result: v.string(),
    })),
  })
  .index("by_chatId", ["chatId"]),
});
</file>

<file path="src/app/components/chat/Message.tsx">
"use client";

import { useState } from "react";
import { UserCircle, Bot, Copy, Check, Heart, ChevronDown, ChevronRight } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { Message as MessageType } from "@/types/chat";
import { formatDistanceToNow } from "date-fns";
import ReactMarkdown from 'react-markdown';
import { logger } from "../../../utils/logger";

type MessageProps = {
  message: MessageType;
};

export function Message({ message }: MessageProps) {
  logger.debug("Rendering message", { 
    role: message.role, 
    hasFunction: !!message.functionCall,
    chatId: message.chatId
  });

  const [copied, setCopied] = useState(false);
  const [liked, setLiked] = useState(false);
  const [expandedFunction, setExpandedFunction] = useState(false);
  const isUser = message.role === "user";

  // Parse function call data if present
  const functionCall = message.functionCall ? JSON.parse(message.functionCall) : null;
  
  const formattedTime = formatDistanceToNow(new Date(message._creationTime), {
    addSuffix: true,
  });

  const copyToClipboard = () => {
    navigator.clipboard.writeText(message.content);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const toggleFunctionDetails = () => {
    setExpandedFunction(!expandedFunction);
  };

  return (
    <div className={`mb-4 flex ${isUser ? 'justify-end' : 'justify-center'} w-full`}>
      <div
        className={`relative rounded-lg ${
          isUser
            ? 'bg-white border border-black shadow-sm p-4 max-w-[75%]' 
            : 'bg-white p-4 max-w-[75%]'
        }`}
      >
        <div className="flex gap-3">
          <div className="flex-1 min-w-0">
            <div className="flex items-center mb-1.5 justify-end">
              <span className="text-xs text-gray-500 opacity-80">
                {formattedTime}
              </span>
            </div>
            
            {isUser ? (
              <div className="prose prose-sm max-w-none break-words whitespace-pre-wrap text-black">
                {message.content}
              </div>
            ) : (
              <div className="prose-sm sm:prose-base lg:prose-lg max-w-none text-black">
                <ReactMarkdown>{message.content}</ReactMarkdown>
              </div>
            )}
            
            {/* Render function call result if present - collapsible version */}
            {functionCall && (
              <div className="mt-2 border border-black rounded-md text-xs overflow-hidden">
                <motion.button
                  onClick={toggleFunctionDetails}
                  className="w-full flex items-center justify-between p-2 bg-white text-black hover:bg-gray-50 transition-colors"
                  whileHover={{ scale: 1.01 }}
                  whileTap={{ scale: 0.99 }}
                >
                  <div className="font-semibold flex items-center">
                    <span className="mr-2">Function called:</span> 
                    <span className="text-blue-600">{functionCall.name}</span>
                  </div>
                  {expandedFunction ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
                </motion.button>
                
                <AnimatePresence>
                  {expandedFunction && (
                    <motion.div 
                      initial={{ height: 0, opacity: 0 }}
                      animate={{ height: "auto", opacity: 1 }}
                      exit={{ height: 0, opacity: 0 }}
                      transition={{ duration: 0.3 }}
                      className="overflow-hidden"
                    >
                      <div className="p-3 border-t border-black bg-white">
                        <div className="mt-1">
                          <div className="font-medium text-black">Arguments:</div>
                          <pre className="p-2 bg-white border border-black rounded overflow-x-auto text-black">
                            {JSON.stringify(functionCall.arguments, null, 2)}
                          </pre>
                        </div>
                        <div className="mt-1">
                          <div className="font-medium text-black">Result:</div>
                          <pre className="p-2 bg-white border border-black rounded overflow-x-auto text-black">
                            {JSON.stringify(functionCall.result, null, 2)}
                          </pre>
                        </div>
                      </div>
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            )}
            
            <div className={`flex mt-2 gap-2 ${isUser ? 'justify-start' : 'justify-end'}`}>
              {!isUser && ( 
                <motion.button
                  onClick={copyToClipboard}
                  className="text-black hover:bg-gray-100 p-1 rounded transition-colors border border-gray-200"
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.9 }}
                  title="Copy to clipboard"
                >
                  {copied ? (
                    <Check size={16} className="text-green-500" />
                  ) : (
                    <Copy size={16} />
                  )}
                </motion.button>
              )}
              
              {!isUser && ( 
                <motion.button
                  onClick={() => setLiked(!liked)}
                  className={`p-1 rounded transition-colors border border-gray-200 ${
                    liked 
                      ? "text-red-500" 
                      : "text-black hover:bg-gray-100"
                  }`}
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.9 }}
                  title={liked ? "Remove reaction" : "React with ❤️"}
                >
                  <Heart size={16} fill={liked ? "currentColor" : "none"} />
                </motion.button>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/components/cta.tsx">
"use client";

import { Reveal } from './animations';
import Link from 'next/link';

export function CTA() {
  return (
    <section className="py-24 relative overflow-hidden bg-white">
      {/* Background pattern */}
      <div className="absolute inset-0 bg-white -z-10" />
      
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        <div className="mx-auto max-w-4xl">
          <Reveal>
            <div className="rounded-3xl bg-white px-6 py-16 sm:p-16 shadow-xl border-2 border-black">
              <div className="mx-auto max-w-2xl text-center">
                <h2 className="text-3xl font-bold tracking-tight text-black sm:text-4xl">
                  ✨ Transform your academic experience
                </h2>
                <p className="mx-auto mt-6 max-w-xl text-lg leading-8 text-black">
                  Connect your Canvas account to Studi and experience the power of AI-assisted learning. Get early access today and be among the first to revolutionize your study habits.
                </p>
                <div className="mt-10 flex flex-col sm:flex-row items-center justify-center gap-6">
                  <Link
                    href="/auth/signup"
                    className="rounded-lg bg-white px-6 py-3 text-base font-medium text-black shadow-sm border-2 border-black hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-black focus:ring-offset-2"
                  >
                    🚀 Get Early Access
                  </Link>
                  <Link
                    href="#features"
                    className="text-base font-medium text-black hover:text-gray-700 flex items-center border-b-2 border-black"
                  >
                    👀 Learn more
                    <svg className="ml-2 h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                    </svg>
                  </Link>
                </div>
              </div>
            </div>
          </Reveal>
          
          {/* Feature highlights */}
          <div className="mt-16 grid grid-cols-1 gap-8 sm:grid-cols-2 lg:grid-cols-3">
            <Reveal delay={0.1}>
              <div className="rounded-xl bg-white p-6 border-2 border-black">
                <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-white border border-black text-black">
                  <span className="text-2xl">⚡</span>
                </div>
                <h3 className="mt-4 text-lg font-medium text-black">Quick Setup</h3>
                <p className="mt-2 text-sm text-black">
                  Connect your Canvas account in seconds and start using Studi immediately with no complex configuration.
                </p>
              </div>
            </Reveal>
            
            <Reveal delay={0.2}>
              <div className="rounded-xl bg-white p-6 border-2 border-black">
                <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-white border border-black text-black">
                  <span className="text-2xl">🔒</span>
                </div>
                <h3 className="mt-4 text-lg font-medium text-black">Privacy Focused</h3>
                <p className="mt-2 text-sm text-black">
                  Your data is secure and private. We only access what's needed to provide you with personalized assistance.
                </p>
              </div>
            </Reveal>
            
            <Reveal delay={0.3}>
              <div className="rounded-xl bg-white p-6 border-2 border-black">
                <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-white border border-black text-black">
                  <span className="text-2xl">📱</span>
                </div>
                <h3 className="mt-4 text-lg font-medium text-black">Works Everywhere</h3>
                <p className="mt-2 text-sm text-black">
                  Access Studi from any device - desktop, tablet, or mobile - for a seamless learning experience.
                </p>
              </div>
            </Reveal>
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/components/features.tsx">
"use client";

import { useState } from 'react';
import { FadeIn, Reveal } from './animations';
import { ReactElement } from 'react';

// Note: You would typically use real icons from an icon library or SVG files
const FeatureIcons: Record<string, () => ReactElement> = {
  Canvas: () => (
    <span className="text-2xl">🎓</span>
  ),
  AI: () => (
    <span className="text-2xl">🤖</span>
  ),
  Homework: () => (
    <span className="text-2xl">⏰</span>
  ),
  Summarization: () => (
    <span className="text-2xl">📝</span>
  ),
  StudyPlans: () => (
    <span className="text-2xl">📅</span>
  ),
  Grades: () => (
    <span className="text-2xl">📊</span>
  ),
};

// Feature data
const features = [
  {
    id: 'canvas',
    name: '🎓 Canvas Integration',
    icon: 'Canvas',
    description: 'Seamlessly connect with your Canvas LMS account to access courses, assignments, and materials in one place.',
    details: 'Studi automatically syncs with your Canvas account, importing your courses, assignments, due dates, and learning materials. No more switching between platforms or missing important deadlines.'
  },
  {
    id: 'ai-assistant',
    name: '🤖 AI-Powered Answers',
    icon: 'AI',
    description: 'Get instant, accurate answers to your questions about course material, assignments, and more.',
    details: 'Our advanced AI understands your course content and can provide explanations, summaries, and answers tailored to your specific classes. It\'s like having a tutor available 24/7.'
  },
  {
    id: 'homework-help',
    name: '⏰ Homework Assistance',
    icon: 'Homework',
    description: 'Receive step-by-step guidance on solving problems and completing assignments.',
    details: 'When you\'re stuck on a homework problem, Studi can break it down into manageable steps, provide hints, and guide you through the solution process without simply giving you the answer.'
  },
  {
    id: 'summarization',
    name: '📝 Content Summarization',
    icon: 'Summarization',
    description: 'Transform lengthy lectures and readings into concise, easy-to-understand summaries.',
    details: 'Upload lecture notes, readings, or recorded lectures, and Studi will generate comprehensive summaries highlighting the key points, making review and study sessions more efficient.'
  },
  {
    id: 'study-plans',
    name: '📅 Personalized Study Plans',
    icon: 'StudyPlans',
    description: 'Get customized study schedules based on your courses, assignments, and learning style.',
    details: 'Studi analyzes your course load, upcoming assignments, and past performance to create optimized study plans that help you prepare effectively and reduce last-minute cramming.'
  },
  {
    id: 'grade-tracking',
    name: '📊 Grade Tracking & Analysis',
    icon: 'Grades',
    description: 'Monitor your academic performance and receive insights to improve your grades.',
    details: 'Keep track of your grades across all courses, identify trends, and get personalized recommendations on where to focus your efforts to improve your academic performance.'
  }
];

export function Features() {
  const [activeFeature, setActiveFeature] = useState(features[0].id);

  return (
    <section id="features" className="py-24 bg-white">
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        <div className="text-center mb-16">
          <Reveal>
            <h2 className="text-base font-semibold leading-7 text-black">✨ Features</h2>
          </Reveal>
          <Reveal delay={0.1}>
            <p className="mt-2 text-3xl font-bold tracking-tight text-black sm:text-4xl">Everything You Need to Excel in Your Studies</p>
          </Reveal>
          <Reveal delay={0.2}>
            <p className="mt-6 text-lg leading-8 text-black max-w-2xl mx-auto">
              Studi combines powerful Canvas integration with AI assistance to transform how you learn and study.
            </p>
          </Reveal>
        </div>

        <div className="grid grid-cols-1 gap-y-16 lg:grid-cols-2 lg:gap-x-12">
          {/* Feature tabs */}
          <div className="flex flex-col space-y-4">
            {features.map((feature, index) => (
              <Reveal key={feature.id} delay={0.1 * index} direction="left">
                <button
                  onClick={() => setActiveFeature(feature.id)}
                  className={`flex items-start p-4 text-left rounded-lg transition-all border ${
                    activeFeature === feature.id
                      ? 'bg-white border-2 border-black shadow-md'
                      : 'border-black hover:bg-gray-50'
                  }`}
                >
                  <div className={`flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-lg ${
                    activeFeature === feature.id
                      ? 'bg-white border-2 border-black'
                      : 'bg-white border border-black'
                  }`}>
                    {FeatureIcons[feature.icon]()}
                  </div>
                  <div className="ml-4">
                    <p className="text-lg font-medium text-black">
                      {feature.name}
                    </p>
                    <p className="mt-1 text-sm text-black">
                      {feature.description}
                    </p>
                  </div>
                </button>
              </Reveal>
            ))}
          </div>

          {/* Feature details */}
          <div className="relative lg:mt-0 mt-8">
            {features.map((feature) => (
              <div
                key={feature.id}
                className={`absolute inset-0 transition-opacity duration-300 ${
                  activeFeature === feature.id ? 'opacity-100 z-10' : 'opacity-0 z-0'
                }`}
              >
                <div className="h-full flex flex-col">
                  <div className="relative aspect-video w-full rounded-2xl bg-white border-2 border-black shadow-xl overflow-hidden">
                    {/* Feature illustration/screenshot would go here */}
                    <div className="absolute inset-0 bg-white">
                      <div className="absolute inset-0 flex items-center justify-center">
                        <div className="p-4">
                          <div className="h-16 w-16 mx-auto rounded-xl bg-white border-2 border-black flex items-center justify-center">
                            {FeatureIcons[feature.icon]()}
                          </div>
                          <h3 className="mt-6 text-xl font-medium text-center text-black">{feature.name}</h3>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div className="mt-8 flex flex-col flex-1">
                    <p className="text-lg text-black flex-1">
                      {feature.details}
                    </p>
                    <div className="mt-6">
                      <a href="#" className="text-black font-medium flex items-center border-b-2 border-black inline-block hover:text-gray-700">
                        👉 Learn more about {feature.name.toLowerCase()}
                        <svg className="ml-1 h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                          <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                        </svg>
                      </a>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/components/footer.tsx">
"use client";

import Link from 'next/link';
import { Reveal } from './animations';

export function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="bg-white border-t-2 border-black">
      <div className="mx-auto max-w-7xl px-6 py-12 md:py-16 lg:px-8">
        <Reveal>
          <div className="xl:grid xl:grid-cols-3 xl:gap-8">
            <div className="space-y-8">
              <div className="flex items-center">
                <span className="text-2xl">📚</span>
                <span className="ml-2 text-xl font-bold text-black">Studi</span>
              </div>
              <p className="text-sm text-black max-w-xs">
                Studi is an AI-powered study assistant designed specifically for Canvas LMS, helping students manage their academic workload and excel in their studies.
              </p>
              <div className="flex space-x-6">
                <a href="#" className="text-black hover:text-gray-700">
                  <span className="sr-only">Twitter</span>
                  <span className="text-2xl">🐦</span>
                </a>
                <a href="#" className="text-black hover:text-gray-700">
                  <span className="sr-only">GitHub</span>
                  <span className="text-2xl">🐙</span>
                </a>
                <a href="#" className="text-black hover:text-gray-700">
                  <span className="sr-only">LinkedIn</span>
                  <span className="text-2xl">💼</span>
                </a>
              </div>
            </div>
            <div className="mt-12 grid grid-cols-2 gap-8 xl:col-span-2 xl:mt-0">
              <div className="md:grid md:grid-cols-2 md:gap-8">
                <div>
                  <h3 className="text-sm font-semibold leading-6 text-black">🚀 Product</h3>
                  <ul className="mt-6 space-y-4">
                    <li>
                      <Link href="#features" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        ✨ Features
                      </Link>
                    </li>
                    <li>
                      <Link href="#testimonials" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        💬 Testimonials
                      </Link>
                    </li>
                    <li>
                      <Link href="/canvas-integration" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        🎓 Canvas Integration
                      </Link>
                    </li>
                    <li>
                      <Link href="/pricing" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        💰 Pricing
                      </Link>
                    </li>
                  </ul>
                </div>
                <div className="mt-10 md:mt-0">
                  <h3 className="text-sm font-semibold leading-6 text-black">📚 Resources</h3>
                  <ul className="mt-6 space-y-4">
                    <li>
                      <Link href="/help" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        ❓ Help Center
                      </Link>
                    </li>
                    <li>
                      <Link href="/guides" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        📖 Study Guides
                      </Link>
                    </li>
                    <li>
                      <Link href="/blog" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        ✏️ Blog
                      </Link>
                    </li>
                    <li>
                      <Link href="/api" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        🔌 API
                      </Link>
                    </li>
                  </ul>
                </div>
              </div>
              <div className="md:grid md:grid-cols-2 md:gap-8">
                <div>
                  <h3 className="text-sm font-semibold leading-6 text-black">🏢 Company</h3>
                  <ul className="mt-6 space-y-4">
                    <li>
                      <Link href="/about" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        ℹ️ About
                      </Link>
                    </li>
                    <li>
                      <Link href="/careers" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        👩‍💻 Careers
                      </Link>
                    </li>
                    <li>
                      <Link href="/contact" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        📞 Contact
                      </Link>
                    </li>
                    <li>
                      <Link href="/partners" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        🤝 Partners
                      </Link>
                    </li>
                  </ul>
                </div>
                <div className="mt-10 md:mt-0">
                  <h3 className="text-sm font-semibold leading-6 text-black">⚖️ Legal</h3>
                  <ul className="mt-6 space-y-4">
                    <li>
                      <Link href="/privacy" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        🔒 Privacy
                      </Link>
                    </li>
                    <li>
                      <Link href="/terms" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        📜 Terms
                      </Link>
                    </li>
                    <li>
                      <Link href="/cookies" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        🍪 Cookie Policy
                      </Link>
                    </li>
                    <li>
                      <Link href="/licenses" className="text-sm leading-6 text-black hover:text-gray-700 border-b border-black">
                        📄 Licenses
                      </Link>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
          <div className="mt-12 border-t-2 border-black pt-8">
            <p className="text-sm text-black xl:text-center">
              &copy; {currentYear} Studi, Inc. All rights reserved. 🎉
            </p>
          </div>
        </Reveal>
      </div>
    </footer>
  );
}
</file>

<file path="src/app/components/hero.tsx">
"use client";

import Link from 'next/link';
import { motion } from 'framer-motion';
import { FadeIn, Reveal, Typewriter } from './animations';

export function Hero() {
  return (
    <section className="relative overflow-hidden bg-white py-20 md:py-32">
      {/* Background pattern */}
      <div className="absolute inset-0 z-0 opacity-[0.03]">
        <svg className="absolute inset-0 h-full w-full" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
          <defs>
            <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
              <path d="M100 0H0V100" fill="none" stroke="black" strokeWidth="1" />
            </pattern>
          </defs>
          <rect width="100%" height="100%" fill="url(#grid)" />
        </svg>
      </div>

      <div className="relative z-10 mx-auto max-w-7xl px-6 lg:px-8">
        <div className="text-center">
          {/* Eyebrow */}
          <FadeIn delay={0.1}>
            <span className="inline-block rounded-full bg-white px-3 py-1 text-sm font-medium text-black border border-black">
              🧠 AI-Powered Study Assistant
            </span>
          </FadeIn>

          {/* Headline */}
          <Reveal delay={0.2}>
            <h1 className="mt-6 text-4xl font-bold tracking-tight text-black sm:text-5xl md:text-6xl">
              Your <span className="text-black border-b-2 border-black">AI-Powered</span> Study Assistant
            </h1>
          </Reveal>

          {/* Typewriter effect */}
          <Reveal delay={0.3}>
            <div className="mt-4 text-xl md:text-2xl font-medium text-black h-8">
              <Typewriter text="✨ Seamlessly integrated with Canvas" className="inline-block" />
            </div>
          </Reveal>

          {/* Description */}
          <Reveal delay={0.4}>
            <p className="mx-auto mt-6 max-w-2xl text-lg leading-8 text-black">
              Studi helps you master your coursework with AI-powered assistance. Organize notes, get instant answers to questions, and connect directly with your Canvas courses.
            </p>
          </Reveal>

          {/* Benefits */}
          <div className="mt-8 flex flex-wrap justify-center gap-4 text-sm">
            <Reveal delay={0.5} direction="up">
              <span className="inline-flex items-center rounded-full bg-white px-3 py-1 font-medium text-black border border-black">
                <svg className="mr-1.5 h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
                🎓 Canvas Integration
              </span>
            </Reveal>
            <Reveal delay={0.6} direction="up">
              <span className="inline-flex items-center rounded-full bg-white px-3 py-1 font-medium text-black border border-black">
                <svg className="mr-1.5 h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
                🤖 AI-Powered Answers
              </span>
            </Reveal>
            <Reveal delay={0.7} direction="up">
              <span className="inline-flex items-center rounded-full bg-white px-3 py-1 font-medium text-black border border-black">
                <svg className="mr-1.5 h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
                📝 Smart Note Organization
              </span>
            </Reveal>
          </div>

          {/* CTA Buttons */}
          <div className="mt-10 flex flex-col sm:flex-row justify-center gap-4">
            <Reveal delay={0.8} direction="up">
              <Link href="/auth/signup" className="rounded-lg bg-white px-6 py-3 text-base font-medium text-black shadow-sm border-2 border-black hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-black focus:ring-offset-2">
                🚀 Get Early Access
              </Link>
            </Reveal>
            <Reveal delay={0.9} direction="up">
              <Link href="#features" className="rounded-lg bg-white px-6 py-3 text-base font-medium text-black shadow-sm border border-black hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-black focus:ring-offset-2">
                👀 Learn More
              </Link>
            </Reveal>
          </div>

          {/* Preview Box */}
          <Reveal delay={1.0}>
            <div className="mt-16 rounded-2xl border-2 border-black bg-white p-4 shadow-lg sm:p-6 lg:p-8 mx-auto max-w-3xl">
              <div className="flex flex-col space-y-4">
                {/* Chat question */}
                <div className="flex items-start space-x-4">
                  <div className="flex-shrink-0">
                    <div className="h-10 w-10 rounded-full bg-white flex items-center justify-center border border-black">
                      <span className="text-lg">👨‍🎓</span>
                    </div>
                  </div>
                  <div className="min-w-0 flex-1">
                    <div className="rounded-lg bg-white p-4 border border-black">
                      <p className="text-sm text-black">Can you help me understand the key concepts from my Canvas lecture on neural networks?</p>
                    </div>
                  </div>
                </div>

                {/* Chat response */}
                <div className="flex items-start space-x-4">
                  <div className="flex-shrink-0">
                    <div className="h-10 w-10 rounded-full bg-white flex items-center justify-center border border-black">
                      <span className="text-lg">🤖</span>
                    </div>
                  </div>
                  <div className="min-w-0 flex-1">
                    <div className="rounded-lg bg-white p-4 border border-black">
                      <p className="text-sm text-black">Based on your Canvas lecture from CS301, here are the key concepts of neural networks:</p>
                      <ul className="mt-2 list-disc pl-5 text-sm text-black space-y-1">
                        <li>Neural networks are computing systems inspired by biological neural networks 🧠</li>
                        <li>They consist of input layers, hidden layers, and output layers 🔄</li>
                        <li>Each connection between neurons has a weight that adjusts during learning ⚖️</li>
                        <li>Activation functions determine the output of a neuron ⚡</li>
                      </ul>
                      <p className="mt-2 text-sm text-black">Would you like me to explain any of these concepts in more detail?</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </Reveal>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/components/navigation.tsx">
"use client";

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { SignInButton, SignUpButton, UserButton, useAuth } from "@clerk/nextjs";

export function Navigation() {
  const [scrolled, setScrolled] = useState(false);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const { isSignedIn } = useAuth();

  // Handle scroll effect
  useEffect(() => {
    const handleScroll = () => {
      const isScrolled = window.scrollY > 10;
      if (isScrolled !== scrolled) {
        setScrolled(isScrolled);
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [scrolled]);

  return (
    <header 
      className={`fixed top-0 left-0 right-0 z-50 py-4 transition-all duration-300 ${
        scrolled 
          ? 'bg-white backdrop-blur-md shadow-md border-b border-black' 
          : 'bg-transparent'
      }`}
    >
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        <div className="flex items-center justify-between">
          {/* Logo */}
          <Link href="/" className="flex items-center">
            <div className="flex items-center">
              <span className="text-2xl">📚</span>
              <span className="ml-2 text-xl font-bold text-black">Studi</span>
            </div>
            <span className="ml-2 inline-flex items-center rounded-md bg-white px-2 py-1 text-xs font-medium text-black ring-1 ring-inset ring-black">BETA</span>
          </Link>

          {/* Desktop Navigation */}
          <nav className="hidden md:flex items-center space-x-8">
            <div className="flex space-x-8 text-sm font-medium text-black">
              <Link href="#features" className="hover:text-gray-700 border-b border-black">✨ Features</Link>
              <Link href="#testimonials" className="hover:text-gray-700 border-b border-black">💬 Testimonials</Link>
              <Link href="#pricing" className="hover:text-gray-700 border-b border-black">💰 Pricing</Link>
              <Link href="/blog" className="hover:text-gray-700 border-b border-black">✏️ Blog</Link>
            </div>
            
            <div className="flex items-center space-x-4">
              {isSignedIn ? (
                <>
                  <Link 
                    href="/dashboard" 
                    className="text-sm font-medium text-black hover:text-gray-700 border-b border-black"
                  >
                    📊 Dashboard
                  </Link>
                  <UserButton afterSignOutUrl="/" />
                </>
              ) : (
                <>
                  <SignInButton mode="modal">
                    <button className="text-sm font-medium text-black hover:text-gray-700 border-b border-black">
                      🔑 Sign in
                    </button>
                  </SignInButton>
                  <SignUpButton mode="modal">
                    <button className="rounded-lg bg-white px-4 py-2 text-sm font-medium text-black shadow-sm hover:bg-gray-100 border-2 border-black focus:outline-none focus:ring-2 focus:ring-black focus:ring-offset-2">
                      🚀 Get Early Access
                    </button>
                  </SignUpButton>
                </>
              )}
            </div>
          </nav>

          {/* Mobile menu button */}
          <button
            type="button"
            className="md:hidden inline-flex items-center justify-center p-2 rounded-md text-black hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-black"
            onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
          >
            <span className="sr-only">Open main menu</span>
            {mobileMenuOpen ? (
              <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            ) : (
              <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            )}
          </button>
        </div>
      </div>

      {/* Mobile menu */}
      <motion.div
        className={`md:hidden ${mobileMenuOpen ? 'block' : 'hidden'}`}
        initial={{ opacity: 0, height: 0 }}
        animate={{ opacity: mobileMenuOpen ? 1 : 0, height: mobileMenuOpen ? 'auto' : 0 }}
        transition={{ duration: 0.3 }}
      >
        <div className="px-4 pt-2 pb-4 space-y-1 bg-white shadow-lg border-t border-b border-black">
          <Link 
            href="#features" 
            className="block px-3 py-2 rounded-md text-base font-medium text-black hover:text-gray-700 hover:bg-gray-100 border-b border-black"
            onClick={() => setMobileMenuOpen(false)}
          >
            ✨ Features
          </Link>
          <Link 
            href="#testimonials" 
            className="block px-3 py-2 rounded-md text-base font-medium text-black hover:text-gray-700 hover:bg-gray-100 border-b border-black"
            onClick={() => setMobileMenuOpen(false)}
          >
            💬 Testimonials
          </Link>
          <Link 
            href="#pricing" 
            className="block px-3 py-2 rounded-md text-base font-medium text-black hover:text-gray-700 hover:bg-gray-100 border-b border-black"
            onClick={() => setMobileMenuOpen(false)}
          >
            💰 Pricing
          </Link>
          <Link 
            href="/blog" 
            className="block px-3 py-2 rounded-md text-base font-medium text-black hover:text-gray-700 hover:bg-gray-100 border-b border-black"
            onClick={() => setMobileMenuOpen(false)}
          >
            ✏️ Blog
          </Link>
          
          <div className="pt-4 pb-3 border-t border-black">
            {isSignedIn ? (
              <div className="flex items-center px-3">
                <div className="flex-shrink-0">
                  <UserButton afterSignOutUrl="/" />
                </div>
                <Link 
                  href="/dashboard" 
                  className="ml-3 block px-3 py-2 rounded-md text-base font-medium text-black hover:text-gray-700 hover:bg-gray-100 border-b border-black"
                  onClick={() => setMobileMenuOpen(false)}
                >
                  📊 Dashboard
                </Link>
              </div>
            ) : (
              <div className="space-y-2 px-3">
                <SignInButton mode="modal">
                  <button 
                    className="w-full flex justify-center items-center px-4 py-2 border border-black shadow-sm text-sm font-medium rounded-md text-black bg-white hover:bg-gray-50"
                    onClick={() => setMobileMenuOpen(false)}
                  >
                    🔑 Sign in
                  </button>
                </SignInButton>
                <SignUpButton mode="modal">
                  <button 
                    className="w-full flex justify-center items-center px-4 py-2 border-2 border-black text-sm font-medium rounded-md text-black bg-white hover:bg-gray-100"
                    onClick={() => setMobileMenuOpen(false)}
                  >
                    🚀 Get Early Access
                  </button>
                </SignUpButton>
              </div>
            )}
          </div>
        </div>
      </motion.div>
    </header>
  );
}
</file>

<file path="src/app/components/testimonials.tsx">
"use client";

import { FadeIn, Reveal } from './animations';

// Testimonial data
const testimonials = [
  {
    id: 1,
    content: "Studi has been a game-changer for my engineering courses. The Canvas integration makes it so easy to access all my course materials and assignments in one place.",
    author: "Alex Johnson",
    role: "Engineering Student, MIT",
    image: "/avatars/avatar-1.png",
    emoji: "🔧"
  },
  {
    id: 2,
    content: "As a pre-med student with a packed schedule, Studi helps me stay on top of my coursework. The AI assistant understands my Canvas materials and explains concepts clearly.",
    author: "Maria Garcia",
    role: "Pre-Med Student, Stanford",
    image: "/avatars/avatar-2.png",
    emoji: "⚕️"
  },
  {
    id: 3,
    content: "The AI homework assistant is incredibly helpful for my math courses. It analyzes problems from my Canvas assignments and guides me through solutions step-by-step.",
    author: "Jamal Williams",
    role: "Computer Science Major, Berkeley",
    image: "/avatars/avatar-3.png",
    emoji: "💻"
  },
  {
    id: 4,
    content: "Our study group uses Studi to prepare for exams. The way it connects directly to Canvas and helps us create study plans based on our course content has improved all our grades.",
    author: "Sarah Chen",
    role: "Business Student, Harvard",
    image: "/avatars/avatar-4.png",
    emoji: "📈"
  },
  {
    id: 5,
    content: "I struggled with keeping track of all my Canvas assignments until I found Studi. Now I never miss a deadline, and my professors have noticed the improvement in my work.",
    author: "David Kim",
    role: "Psychology Major, Princeton",
    image: "/avatars/avatar-5.png",
    emoji: "🧠"
  }
];

export function Testimonials() {
  return (
    <section id="testimonials" className="py-24 bg-white">
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        {/* Section header */}
        <div className="mx-auto max-w-2xl text-center mb-16">
          <Reveal>
            <h2 className="text-base font-semibold leading-7 text-black">💬 Testimonials</h2>
          </Reveal>
          <Reveal delay={0.1}>
            <p className="mt-2 text-3xl font-bold tracking-tight text-black sm:text-4xl">
              Students Love Using Studi
            </p>
          </Reveal>
          <Reveal delay={0.2}>
            <p className="mt-6 text-lg leading-8 text-black">
              Hear from students who have transformed their academic experience with our Canvas-integrated AI study assistant.
            </p>
          </Reveal>
        </div>

        {/* Testimonial grid */}
        <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
          {testimonials.map((testimonial, index) => (
            <Reveal key={testimonial.id} delay={0.1 * index}>
              <div className="flex flex-col h-full overflow-hidden rounded-2xl bg-white p-6 shadow border-2 border-black">
                <div className="flex-1">
                  <div className="flex items-center gap-x-2 text-black mb-4">
                    <span className="text-2xl">{testimonial.emoji}</span>
                    {[...Array(5)].map((_, i) => (
                      <svg key={i} className="h-5 w-5 flex-none" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fillRule="evenodd" d="M10.868 2.884c-.321-.772-1.415-.772-1.736 0l-1.83 4.401-4.753.381c-.833.067-1.171 1.107-.536 1.651l3.62 3.102-1.106 4.637c-.194.813.691 1.456 1.405 1.02L10 15.591l4.069 2.485c.713.436 1.598-.207 1.404-1.02l-1.106-4.637 3.62-3.102c.635-.544.297-1.584-.536-1.65l-4.752-.382-1.831-4.401z" clipRule="evenodd" />
                      </svg>
                    ))}
                  </div>
                  <p className="text-base text-black mb-6">"{testimonial.content}"</p>
                </div>
                <div className="flex items-center gap-x-4">
                  <div className="h-10 w-10 rounded-full bg-white flex items-center justify-center text-black overflow-hidden border border-black">
                    {testimonial.image ? (
                      <img src={testimonial.image} alt={testimonial.author} className="h-full w-full object-cover" />
                    ) : (
                      <span className="text-lg">👤</span>
                    )}
                  </div>
                  <div>
                    <h3 className="text-sm font-medium text-black">{testimonial.author}</h3>
                    <p className="text-xs text-black">{testimonial.role}</p>
                  </div>
                </div>
              </div>
            </Reveal>
          ))}
        </div>

        {/* CTA */}
        <div className="mt-16 text-center">
          <Reveal>
            <a href="#" className="inline-flex items-center rounded-lg bg-white px-6 py-3 text-base font-medium text-black shadow-sm border-2 border-black hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-black focus:ring-offset-2">
              🚀 Join these students
              <svg className="ml-2 h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
            </a>
          </Reveal>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="README.md">
# Studi - AI-Powered Canvas LMS Assistant

Studi is an AI-powered chat application that helps students interact with their Canvas Learning Management System (LMS) data. It provides a conversational interface to access course information, assignments, announcements, and more.

## Features

- **AI Chat Interface**: Conversational UI powered by OpenAI's GPT models
- **Canvas LMS Integration**: Connect your Canvas account to access your educational data
- **Function Calling**: AI can retrieve specific Canvas data when needed
- **Responsive Design**: Works on desktop and mobile devices
- **User Authentication**: Secure login with Clerk authentication
- **Structured Logging**: Comprehensive logging system for debugging and monitoring
- **Modern Landing Page**: Engaging, conversion-focused design with Canvas integration emphasis

### Canvas API Features

Studi integrates extensively with the Canvas LMS API to provide access to:

- Courses, modules, and content
- Files and resources
- Assignments and grades
- Discussions and announcements
- User information and enrollments
- Calendar events and deadlines
- Quizzes and surveys

All these features are accessible through natural language conversations with the AI assistant.

## Landing Page

The Studi landing page is designed to showcase the application's value proposition with a focus on Canvas LMS integration. Key sections include:

- **Hero Section**: Introduces Studi as an AI-powered study assistant with Canvas integration
- **Features Section**: Highlights key capabilities including Canvas data access, AI assistance, and study tools
- **Testimonials**: Showcases student experiences with the platform
- **Call to Action**: Encourages early access sign-ups
- **Footer**: Provides navigation, resources, and company information

The landing page is fully responsive and designed with modern web standards using Tailwind CSS and React components.

## Tech Stack

- **Frontend**: Next.js 14, React, TypeScript, Tailwind CSS
- **Backend**: Convex for database and serverless functions
- **Authentication**: Clerk
- **AI**: OpenAI API with function calling
- **Canvas Integration**: Canvas LMS REST API

## Getting Started

### Prerequisites

- Node.js 18+ and npm
- Convex account
- Clerk account
- OpenAI API key
- Canvas LMS account (for full functionality)

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/studi.git
   cd studi
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Set up environment variables:
   Create a `.env.local` file with the following variables:
   ```
   NEXT_PUBLIC_CONVEX_URL=your_convex_url
   NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_clerk_publishable_key
   CLERK_SECRET_KEY=your_clerk_secret_key
   OPENAI_API_KEY=your_openai_api_key
   ```

4. Start the development server:
   ```bash
   npm run dev
   ```

5. Initialize Convex:
   ```bash
   npx convex dev
   ```

### Canvas Integration Setup

1. Go to your Canvas LMS account
2. Generate a new API token in your profile settings
3. In the Studi application, navigate to Settings
4. Enter your Canvas URL and API token
5. Enable Canvas integration

## Project Structure

```
studi/
├── src/                  # Source code
│   ├── app/              # Next.js app router
│   ├── components/       # React components
│   ├── utils/            # Utility functions
│   └── types/            # TypeScript types
├── convex/               # Convex backend
│   ├── schema.ts         # Database schema
│   ├── users.ts          # User-related functions
│   ├── messages.ts       # Message-related functions
│   ├── canvas.ts         # Canvas API integration
│   └── openai.ts         # OpenAI integration
├── public/               # Static assets
└── docs/                 # Documentation
    ├── architecture.md   # Architecture overview
    ├── logger.md         # Logger documentation
    └── canvas-api.md     # Canvas API documentation
```

## Documentation

For more detailed documentation, see the `docs` directory:

- [Architecture Overview](docs/architecture.md)
- [Logger Documentation](docs/logger.md)
- [Canvas API Documentation](docs/canvas-api.md)

## Canvas API Integration

The Canvas API integration is one of the core features of Studi. It allows the chatbot to:

1. **Retrieve Course Information**: Access course syllabi, modules, and materials
2. **Track Assignments**: View upcoming assignments, due dates, and submission status
3. **Access Grades**: Check grades for assignments and overall course performance
4. **View Announcements**: Read course announcements and updates
5. **Participate in Discussions**: Access discussion forums and threads
6. **Manage Files**: Browse and download course files and resources
7. **Check Calendar Events**: View upcoming events and deadlines

For developers, the Canvas API functions are organized in `convex/canvas.ts` and follow a consistent pattern with standardized error handling and response formatting.

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- OpenAI for their powerful language models
- Canvas LMS for their API
- Convex for their real-time backend platform
- Clerk for authentication services
</file>

</files>
